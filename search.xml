<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React开发框架搭建]]></title>
    <url>%2Fkms-123%2FReact%E4%B9%8B%E6%97%85-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[一. 介绍 ^:在此为工程目录 二. 创建初始化项目1careta-react-app kuangjia 三. 安装其他第三方模块1yarn add axios antd less less-loader react-redux react-router-dom babel-plugin-import 四. 配置less-loader 导数webpack配置 1yarn eject ^/config/webpack.config.js 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// style files regexesconst cssRegex = /\.css$/;const cssModuleRegex = /\.module\.css$/;const sassRegex = /\.(scss|sass)$/;const sassModuleRegex = /\.module\.(scss|sass)$/;+ const lessRegex = /\.(less|less)$/;+ const lessModuleRegex = /\.module\.(less|less)$/;&#123; test: sassModuleRegex, use: getStyleLoaders( &#123; importLoaders: 3, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: &#123; getLocalIdent: getCSSModuleLocalIdent, &#125;, &#125;, 'sass-loader' ),&#125;,+ &#123;+ test: lessRegex,+ exclude: lessModuleRegex,+ use: getStyleLoaders(+ &#123;+ importLoaders: 2,+ sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,+ &#125;,+ 'less-loader'+ ),+ sideEffects: true,+ &#125;,+ &#123;+ test: lessModuleRegex,+ use: getStyleLoaders(+ &#123;+ importLoaders: 2,+ sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,+ modules: true,+ getLocalIdent: getCSSModuleLocalIdent,+ &#125;,+ 'less-loader'+ ),+ &#125;, 五. 配置antd主题 并添加按需引入(按需引入的插件在第三步已经安装了) ^/package.json中 (按需引入) 123456789101112131415161718192021222324252627 "babel": &#123; "presets": [ "react-app" ], "plugins": [ [ "@babel/plugin-proposal-decorators", &#123; "legacy": true &#125; ], [ "@babel/plugin-proposal-class-properties", &#123; "loose": true &#125; ], [ "import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": true &#125; ] ]&#125; ^/config/webpack.config.js 中(定制主题色) 123456789101112131415161718192021222324252627282930313233 if (preProcessor) &#123; loaders.push( &#123; loader: require.resolve('resolve-url-loader'), options: &#123; sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, &#125;, &#123; loader: require.resolve(preProcessor), options: &#123; sourceMap: true, &#125;, &#125; ); + let loader = &#123; + loader: require.resolve(preProcessor), + options: &#123; + sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, + &#125; + &#125; + if (preProcessor === "less-loader") &#123; + loader.options.modifyVars = &#123; + '@primary-color': '#f9c700', + '@link-color': '#1DA57A', + '@border-radius-base': '2px' + &#125; + loader.options.javascriptEnabled = true + &#125; + loaders.push(loader); &#125; return loaders;&#125;; 六. 页面结构定义]]></content>
      <categories>
        <category>React</category>
        <category>Redux</category>
        <category>框架搭建</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React之旅二--Redux]]></title>
    <url>%2Fkms-123%2FReact%E4%B9%8B%E6%97%85-Redux.html</url>
    <content type="text"><![CDATA[什么是Redux:Reducer+FluxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。 Redux工作流程我们将工作流程比作用户去图书管借书的流程 安装redux 123yarn add redux&amp;&amp;npm i redux 创建一个Store（图书馆管理员） 12345678910111213141516171819202122 // index.js import &#123; createStore &#125; from 'redux' const store = createStore(); export default store ``` 5. 创建图书馆系统,并将系统交给管理员 ```js // Store/reducer.js const defaultState = &#123;&#125; /* state：上一次state中存储的数据 action：用户传递进来修改的方法 */ export default (state = defaultState , action) =&gt; &#123; return state; &#125; // Store/index.js import &#123; createStore &#125; from 'redux' import reducer from './reducer.js' const store = createStore(reducer); export default store 初步的使用渲染数据 12345678910111213141516171819202122232425262728293031323334// Store/redux.jsconst defaultState = &#123;inputValue: '',data : [ 'Japanese princess to wed commoner.', 'Los Angeles battles huge wildfires.', ]&#125;export default (state = defaultState , action) =&gt; &#123; return state;&#125;// Store/index.jsimport &#123; createStore &#125; from 'redux'import reducer from './reducer.js'const store = createStore(reducer);export default store// todoList.jsximport React, &#123; Component &#125; from 'react' import store from '../Store/index.js'class TodoList extends Component &#123; constructor(props) &#123; super(props) // 也可以 this.state = store.getState() this.state = &#123; inputValue: '', // 在这里获取redux中的数据 data:store.getState().data &#125; &#125; componentDidMount() &#123; &#125; render() &#123; &#125;&#125; 修改store中的数据 1234567891011121314151617181920// todoList.jsx // 创建修改方法 调用store.dispatch方法handleInputChange = (e) =&gt; &#123; const action = &#123; type: 'change_input_value', value:e.target.value &#125; store.dispatch(action);&#125;// reducer.js// 接受方法 添加判断 并修改属性值// reducer中不能修改原有的state中的值 只能先深拷贝一次export default (state = defaultState, action) =&gt; &#123; if (action.type === 'change_input_value') &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; return state;&#125; 组件中监听redux修改了 返回最新的数据 12345678910111213constructor(props) &#123; // 添加监听的方法 store.subscribe(this.handleChangeStore)&#125;// 监听若数据修改 在组件中重新赋值handleChangeStore = () =&gt; &#123; this.setState(() =&gt; &#123; return &#123; inputValue: store.getState().inputValue, data:store.getState().data &#125; &#125;)&#125; 统一管理action 1234567新建actiontypes.js将所有的action放在这里定义并导出 组件和redux使用则单独引入解决action拼写错误，缺不报错问题export const CHANGE_INPUT_VALUE = 'change_input_value'export const ADD_ITEM = 'add_item'export const DELETE_ITEM = 'delete_item' 优化代码 提高可读性方便自动化测试 1234567891011121314// 创建 actionCreateor.js// 将原来在组件中创建的action 统一放在此处创建import &#123; CHANGE_INPUT_VALUE, ADD_ITEM, DELETE_ITEM&#125; from './actiontypes.js'export const getInputValue = (value) =&gt; ( &#123; type: CHANGE_INPUT_VALUE, value&#125;) export const addDataItem = () =&gt; ( &#123; type: ADD_ITEM,&#125;) export const deleteItem = (index) =&gt; ( &#123; type: DELETE_ITEM, index&#125;) 一个完整的列子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// TodoList.jsximport React, &#123; Component, Fragment &#125; from 'react' import &#123; Input, Button, List&#125; from 'antd'import store from '../Store'import &#123; getInputValue, addDataItem, deleteItem &#125; from '../Store/actionCreateor.js'class TodoListMy extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; inputValue: '', data:store.getState().data // 页面加载就获取redux中存储的值 &#125; store.subscribe(this.handleChangeStore)// 添加redux监听 数据发生改变重新赋值 &#125; // input发生改变事件 handleChangeInput = (e) =&gt; &#123; let action =getInputValue(e.target.value) store.dispatch(action) &#125; // 监听redux属性值发生改变 冲新赋值 handleChangeStore = () =&gt; &#123; this.setState(() =&gt; &#123; return &#123; inputValue: store.getState().inputValue, data:store.getState().data &#125; &#125;) &#125; // 添加一条数据 handleAddItem = () =&gt; &#123; if (this.state.inputValue === '') &#123; return &#125; let action = addDataItem() store.dispatch(action) &#125; // 删除一条数据 handleDeleteItem = (index) =&gt; &#123; let action = deleteItem(index) store.dispatch(action) &#125; render() &#123; return ( &lt;Fragment&gt; &lt;Input style=&#123;&#123; width: '300px' &#125;&#125; placeholder="请输入内容" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleChangeInput&#125;&gt;&lt;/Input&gt; &lt;Button onClick=&#123;this.handleAddItem&#125; type="primay"&gt;提交&lt;/Button&gt; &lt;List style=&#123;&#123;width:'300px'&#125;&#125; bordered dataSource=&#123;this.state.data&#125; renderItem=&#123;(item,index) =&gt; ( &lt;List.Item onClick=&#123;this.handleDeleteItem.bind(this,index) &#125; &gt;&#123;item&#125;&lt;/List.Item&gt; ) &#125; /&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoListMy // redux.jsimport &#123; CHANGE_INPUT_VALUE, ADD_ITEM, DELETE_ITEM&#125; from './actiontypes.js'const defaultState = &#123;inputValue: '',data : [ 'Racing car sprays burning fuel into crowd.', 'Japanese princess to wed commoner.', ]&#125;/* state：上一次state中存储的数据 action：用户传递进来修改的方法*/export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_VALUE) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState &#125; if (action.type === ADD_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.data.push(newState.inputValue); newState.inputValue = ''; return newState &#125; if (action.type === DELETE_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.data.splice(action.index, 1); return newState &#125; return state;&#125; 拆分reducer 123456789101112131415161718192021222324252627// store/reducer.jsimport &#123; combineReducers &#125; from 'redux'import headerReducer from '../common/header/store/reducer.js'export default combineReducers(&#123; header:headerReducer&#125;)// ../common/header/store/reducer.js 在这里的reducer写法与之前一样import &#123; CHANGE_INPUT_IS_FOCUS &#125; from '../../../store/actionTypes.js'const defaultState = &#123; focused:false,&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_IS_FOCUS) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.focused = action.value; return newState &#125; return state&#125;// 注意组件中 也要加模块名 const mapStateToProps = (state) =&gt; &#123; return &#123; focused:state.header.focused, &#125;&#125; redux 核心API createStore // 创建storecreateStore(reducer,window.REDUX_DEVTOOLS_EXTENSION &amp;&amp; window.REDUX_DEVTOOLS_EXTENSION()); store.dispatch(action) // 修改Store中属性的唯一方法 store.getState() // 返回Store中所有的属性值 store.subscribe() // 监听Store中有属性值发生改变 ；立即调用用户设置的方法 combineReducers({}), // 合并多个小的reducer 返回一个大的reducer 类似vuex模块的概念redux中间件 什么是redux中间件： 指的是action和store之间。即dispatch的封装和升级。 redux–redux-thunk 用户可以在action中发送异步请求获取数据(thunk将action转换成函数) 安装 1npm install redux-thunk 使用 12345// 在创建Store的文件中引入import &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './reducer.js'import thunk from 'redux-thunk';const store = createStore(reducer,thunk); 为了配合redux-devTools 这样使用 12345678910import &#123; createStore, applyMiddleware,compose &#125; from 'redux';import reducer from './reducer.js'import thunk from 'redux-thunk';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123; &#125;) : compose;const enhancer = composeEnhancers( applyMiddleware(thunk),);const store = createStore(reducer,enhancer); 发送异步请求 获取数据 1234567891011121314151617181920212223242526272829303132// actionCreateor.js中import &#123; SET_DATA_LIST &#125; from './actiontypes.js'export const setDataList = (data) =&gt; ( &#123; type: SET_DATA_LIST, data&#125;) export const getItemList = (index) =&gt; &#123; return (dispatch) =&gt; &#123; // 第一个参数dispatch是默认的=== store.disptch axios.get('/api/todoList') .then(res =&gt; &#123; let action = setDataList(res.data) dispatch(action) &#125;) .catch(error =&gt; &#123; console.log(error);&#125;); &#125;&#125;// reduerc.js 中 添加修改方法if (action.type === SET_DATA_LIST) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.data = action.data; return newState&#125;// 组件中 使用actionimport &#123; getItemList &#125; from '../Store/actionCreateor.js'componentDidMount() &#123; let action = getItemList() store.dispatch(action)&#125;// actiontypes.js 添加对应的变量export const SET_DATA_LIST = 'set_data_list' redux-saga 安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 npm install --save redux-saga``` 2. 使用```js // Store中添加saga配置 import &#123; createStore, applyMiddleware,compose &#125; from &apos;redux&apos;; import reducer from &apos;./reducer.js&apos; import createSagaMiddleware from &apos;redux-saga&apos; import todoSaga from &apos;./sagas.js&apos; const sagaMiddleware = createSagaMiddleware() const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123; &#125;) : compose; const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware), ); const store = createStore(reducer, enhancer); sagaMiddleware.run(todoSaga) export default store // 在组件中使用 import &#123; geiInitList &#125; from &apos;../Store/actionCreateor.js&apos; componentDidMount() &#123; let action = geiInitList() store.dispatch(action) &#125; // 添加自定义saga 用来存放异步亲求数据的方法 // saga也可以监听action的type值 与redux一样 import &#123; put, takeEvery &#125; from &apos;redux-saga/effects&apos; import &#123; GET_INIT_LIST &#125; from &apos;./actiontypes.js&apos; import &#123; setDataList &#125; from &apos;./actionCreateor.js&apos; import axios from &apos;axios&apos; // saga监听action的类型 是GET_INIT_LIST（get_init_list）就会调用getInitList方法 function* todoSaga() &#123; yield takeEvery(GET_INIT_LIST, getInitList); &#125; // 调用本方法后 获取到的数据 使用put方法返回给redux.js function* getInitList() &#123; const res = yield axios.get(&apos;/api/todoList&apos;); let action = setDataList(res.data) yield put(action) &#125; export default todoSaga; // reducer.js // 判断action的类型 进行数据修改 if (action.type === GET_INIT_LIST) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.data = action.data; return newState &#125; // actionCreateor.js // saga 使用的action export const geiInitList = () =&gt; ( &#123; type: GET_INIT_LIST, &#125;) // actiontypes.js export const GET_INIT_LIST = &apos;get_init_list&apos; react-redux的使用 安装 react-redux 1npm i react-redux 创建redux数据仓库（store） 1234import &#123; createStore &#125; from 'redux'import reducer from './reducer.js'const store = createStore(reducer)export default store 在渲染的父组件中（App.js） 12345678910import React from 'react'import store from '../Store/index.js'import &#123; Provider &#125; from 'react-redux'import TodoList from './TodoList/TodoList.jsx'const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList&gt;&lt;/TodoList&gt; &lt;/Provider&gt;)export default App 在TodoList中使用（TodoList.jsx） 123456789101112131415161718192021222324252627282930313233343536373839import React,&#123; Component &#125; from 'react'import store from '../Store/index.js'import &#123; connect &#125; from 'react-redux'class TodoList extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &lt;input onChange=&#123;this.props.handleChangeInputValue&#125; placeholder="请输入内容" value=&#123;this.props.inputValue&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;dell&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125;// 获取store中的数据 在这里定义数据 jsx中就可以使用this.props.inputValue方式显示const mapStateToProps = (state)=&gt;&#123; return &#123; inputValue:state.inputValute // 从redux中获取inputValue &#125;&#125;// store.dispatch 将修改redux的方法放在这里 jsx即可使用this.props.handle 使用const mapDispatchProps = (dispatch)=&gt;&#123; return &#123; handleChangeInputValue(e)&#123; let action = &#123; type: 'change_input_value', value:e.target.value &#125; dispatch(action) &#125; &#125;&#125;// connect 会自动监听 不需要我们在使用subscribe 方法了export default connect(mapStateToProps, mapDispatchProps)(TodoList) 创建reducer.js 并添加对应的方法 修改store中数据 1234567891011const defaultState = &#123; inputValue:''&#125;export default (state=defaultState, action)=&gt;&#123; if(action.type === 'change_input_value')&#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value return newState &#125; return state&#125; immutable.js的使:使store 变成不可更改的对象 安装 1yarn add immutable 使用 12345678910111213141516171819202122232425262728// header.reducer.js // 引入immutable 并将初始数据转换成immutable对象import &#123; CHANGE_INPUT_IS_FOCUS &#125; from './actionTypes.js' import &#123; fromJS &#125; from 'immutable' const defaultState = fromJS( &#123; focused:false, &#125; ) export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_IS_FOCUS) &#123; // const newState = JSON.parse(JSON.stringify(state)); // newState.focused = action.value; // return newState // state.set()方法是将原来的数据与新的数据对比 返回一个全新的对象 return state.set('focused',action.value) &#125; return state &#125; // 在组件中使用 // 不需要在引用immutable const mapStateToProps = (state) =&gt; &#123; return &#123; focused:state.header.get('focused'), &#125; &#125; Api锦集 123456xxx.formJS() // 将js转换成immutable对象xxx.get('属性').get('') // 获取属性值xxx.getIn(['模块','属性']) // 获取属性值xxx.toJS('') // 将immutable对象转成js对象xxx.set('属性',"值").set('属性',"值") // reducer.js 中修改一个state中的值xxx.merge(&#123;&#125;) [([])], // reducer.js 中修改多个state中的值 可以用对象的形式 多个set用merge性能能高 缺点：immutable只是将reducer中的数据转换成immutable对象 但是在组件中使用 获取数据的时候 focused:state.header.get(‘focused’), 是先调用js对象 再去调用immutable对象中的属性值 解决办法：统一成immutable对象 使用redux-immutable库 使用redux-immutable管理数据 安装 1yarn add redux-immutable 使用 12345678910111213141516// 在总的reducer.js中 将原来import &#123; combineReducers &#125; from 'redux' 更换为以下方式 import &#123; combineReducers &#125; from 'redux-immutable' import headerReducer from '../common/header/store/reducer.js' export default combineReducers(&#123; header:headerReducer &#125;) // 组件中获取值 const mapStateToProps = (state) =&gt; &#123; return &#123; // 二种方式都可以 focused:state.get('header').get('focused'), // focused:state.getIn(['header','focused']) &#125; &#125; react-router-dom react路由的使用 安装 1yarn add react-router-dom 使用 123456789101112131415161718192021// App.js import &#123; BrowserRouter, Route&#125; from 'react-router-dom' function App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;&gt; &lt;Header&gt;&lt;/Header&gt; // 路由包裹器他下面只能有一个子元素 &lt;BrowserRouter&gt; &lt;&gt; // path="/" 路径 // exact 匹配路径与url一直才会显示 // render() 需要渲染的组件 &lt;Route path="/" exact render=&#123;() =&gt; &lt;div&gt;home&lt;/div&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path="/details" exact render=&#123;() =&gt; &lt;div&gt;details&lt;/div&gt;&#125;&gt;&lt;/Route&gt; &lt;/&gt; &lt;/BrowserRouter&gt; &lt;/&gt; &lt;/Provider&gt; ); &#125; 常用Api BrowserRouter： 路由包裹器 包裹Route Route: 路由 path： 路由地址 exact： 匹配路径与url一直才会显示 render：渲染的页面 component： 渲染的组件 传组件 Link 用户路由跳转 to：路由地址 withRouter：多层级页面 获取路由传递的参数 组件套组件 路由参数只能在路由组件中获取 使用withRouter可以使子组件也能获取到路由参数 export default connect(mapState,mapDispatch)(withRouter(Detail)) 使用方法 Redirect： 路由重定向 to：路由地址异步组件 减少打包体积 提高首页渲染速度 安装 1yarn add react-loadable 使用 12345678910111213141516import Loadable from 'react-loadable';import React from 'react'const LoadableComponent = Loadable(&#123; // 加载组件 loader: () =&gt; import('./index.js'), // 组件还没有加载好显示的提示信息 loading() &#123; return &lt;div&gt;正在加载&lt;/div&gt; &#125;&#125;)export default ()=&gt; &lt;LoadableComponent&gt;&lt;/LoadableComponent&gt; //在引入路由组件的地方更改下 引入异步组件 如果路由传参数了 请记得使用withRouter：多层级页面 // import Detail from './pages/detail/index' import Detail from './pages/detail/loadable.js' yarn 常用的命令 yarn init 初始化 yarn add * 安装一个库 yarn remove 删除一个库 yarn install 安装一个框架所有的包 yarn upgrade * 升级一个包注意 reducer必须是纯函数 什么是纯函数：给出固定的输入，必须给出固定的输出，而且不会有副作用 只有store才能修改store中的值 redux中修改即store中修改 redux的属性是单一数据流 redux中不能又异步操错，setTimout,setInterval 因为他是纯函数]]></content>
      <categories>
        <category>React</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>学习</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端手势]]></title>
    <url>%2Fkms-123%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E5%8A%BF.html</url>
    <content type="text"><![CDATA[1. 什么是移动端手势事件（touch）：在手机或平板上手指与屏幕接触产生交互的事件。2. touch有哪些事件 touchstart： 当手指触摸屏幕时触发如何使用 123el.addEventListener(&apos;touchstart&apos;,function(event)&#123; ...&#125;,false) touchmove： 当手指在屏幕滑动时不断的触发 如何使用 123el.addEventListener(&apos;touchmove&apos;,function(event)&#123; ...&#125;,false) touchend： 当手指从屏幕上移开时触发 如何使用 123el.addEventListener(&apos;touchend&apos;,function(event)&#123; ...&#125;,false) touchcancel： 当系统停止跟踪触摸时触发（意外停止触摸，如突然来了电话） 如何使用 123el.addEventListener(&apos;touchcancel&apos;,function(event)&#123; ...&#125;,false) 缺点每个元素都要添加事件繁琐 优化：123document.addEventListener('touch***'，function(event)&#123; //event 当前手指触摸的元素。 若又其他需求也可以添加判断 判断e.target属性&#125;,false) 3. touchEvent事件对象 touches：当前屏幕上所有的手指对象 targetTouches：当前元素上的手指对象(推荐使用) changedTouches：当前屏幕上变化的手指对象（屏幕触摸的手指从无到有，或从有到无，只会返回点击或离开的手指） event(移动端一般使用client) clientx：相对于当前视口 当前手指的位置距离视口的左上角X的值 clienty：相对于当前视口 当前手指的位置距离视口的左上角Y的值 screenX: 当前手指的位置距离屏幕的左上角X的值 screenY：当前手指的位置距离屏幕的左上角Y的值 pageX: 相对于当前页面的内容 当前手指的位置距离当前内容的左上角X的值 pageY: 相对于当前页面的内容 当前手指的位置距离当前内容的左上角Y的值]]></content>
      <tags>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG-path路径]]></title>
    <url>%2Fkms-123%2FSVG-path%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[一.SVG二. 路径 path：元素是SVG基本形状中最强大的一个。 你可以用它创建线条, 曲线, 弧形等等。 他有哪些属性 M(moveto)x y：移动到指定坐标，xy分别为x轴和y轴的坐标点，即画笔的起点 L(lineto)x y: 在初始位置（M 画的起点）和x y确定的坐标画一条线(两点一线) H(horizontal lineto) x: 沿着x轴移动一段位置 H:向左，h：向右 V(vertical lineto) y: 沿着y轴移动一段位置 C(curveto) x1 y1 x2 y2 x y: 三次贝塞尔曲线 当前点为起点，xy为终点，起点和x1y1控制曲线起始的斜率，终点和x2y2控制结束的斜率。 S(smooth curveto)x2 y2 x y: 简化的贝塞尔曲线 如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。 如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。 Q(quadratic Bézier curve) x1 y1 x y:二次贝塞尔曲线Q 只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。 T(smooth quadratic Bézier curveto): Q命令的简写命令。 与S命令相似，T也会通过前一个控制点，推断出一个新的控制点。 1.T命令前面必须是一个Q命令，或者是另一个T命令 2.如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线 A(elliptical Arc)rx,ry x-axis-rotation large-arc-flag sweep-flag x,y: rx 弧的半长轴长度 ry 弧的半短轴长度 x-axis-rotation 是此段弧所在的x轴与水平方向的夹角，即x轴的逆时针旋转角度，负数 代表顺时针旋转角度。 large-arc-flag 为1表示大角度弧线，0表示小角度弧线 sweep-flag 为1表示从起点到终点弧线绕中心顺时针方向，0表示逆时针方向。 xy 是终点坐标。 Z(closepath):从当前位置到起点画一条直线闭合。 配套的API getPointAtLength([number]): 获取path路径的长度 不加参数为总长度 加了参数为当前长度在path（x,y）点上]]></content>
      <categories>
        <category>SVG</category>
      </categories>
      <tags>
        <tag>SVG</tag>
        <tag>path</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt微信分享微信支付]]></title>
    <url>%2Fkms-123%2FNuxt%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.html</url>
    <content type="text"><![CDATA[一. 了解微信官方文档地址链接 二. 安装微信SDK1npm install weixin-js-sdk --save 三. 封装微信分享js(wx-share.js)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Vue from 'vue';import wx from 'weixin-js-sdk';// 引入微信sdk/*post post请求方法webShare 获取 wx.config(&#123;&#125;)需要的参数baseURLError 项目地址 用于拼接链接*/import &#123; post, webShare, baseURLError &#125; from '@/server';// 封装好的 axios 请求Vue.prototype.$wechat = wx;const wechatShare = &#123; install(Vue) &#123; Vue.prototype.wxShare = function(shareData) &#123; const pageUrl = window.location.href;// 获取当前地址 用于请求 获取wx.config(&#123;&#125;)需要的参数 post(webShare, &#123; url: encodeURIComponent(pageUrl) &#125;) .then((res) =&gt; &#123; const data = res.data; this.$wechat.config(&#123; debug: false, appId: data.appId, timestamp: data.timestamp, nonceStr: data.nonceStr, signature: data.signature, jsApiList: [ 'updateAppMessageShareData', 'updateTimelineShareData' ]// 你需要使用的微信api功能 必填 &#125;); // 完成配置 加载分享功能 // shareData参数是我们调用传进来的对象 this.$wechat.ready(() =&gt; &#123; // 自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0） this.$wechat.updateAppMessageShareData(&#123; title: shareData.title, desc: shareData.desc, link: baseURLError + shareData.link, imgUrl: shareData.imgUrl, success() &#123; // 设置成功 &#125;, cancel() &#123; &#125; &#125;); // 自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0） this.$wechat.updateTimelineShareData(&#123; title: shareData.title, desc: shareData.desc, link: baseURLError + shareData.link, imgUrl: shareData.imgUrl, success() &#123; // 设置成功 &#125;, cancel() &#123; &#125; &#125;); &#125;); &#125;); &#125;; &#125;&#125;;Vue.use(wechatShare); 四. 如何使用 在nuxt.config.js中添加 123plugins: [ &#123; src: '~plugins/wx-share', ssr: false &#125;,], 页面中使用 123456789101112131415&lt;template&gt;···&lt;/template&gt;&lt;script&gt;export default &#123; mounted() &#123; /* *title 分享的标题 *desc 分享的文本简介内容 *link 分享出去的链接地址（必须http://开头，不然你会哭） * imgUrl分享出去的图片（必须http://开头，不然你会哭） */ this.wxShare(&#123; title: '', desc: '', link: '', imgUrl: '' &#125;); &#125;,&#125;; 五. 微信JSAPI 封装微信支付(wx-pay.js) 创建js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取url中的参数export function getUrlParam(name) &#123; const reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)'); // 构造一个含有目标参数的正则表达式对象 const r = window.location.search.substr(1).match(reg); // 匹配目标参数 if (r != null) &#123; return unescape(r[2]); &#125; return null; // 返回参数值&#125;// 这里请使用var 声明 不然下面无法获取到wxData 导致无法唤起支付// eslint-disable-next-line no-unused-vars// eslint-disable-next-line no-varvar wxData = &#123;&#125;;// 调用微信JS api 支付/**success 支付成功的回调方法*error 支付失败的回调方法*/export function jsApiCall(success, error) &#123; // eslint-disable-next-line no-undef WeixinJSBridge.invoke('getBrandWCPayRequest', &#123; 'appId': wxData.appId, // 公众号名称，由商户传入 'timeStamp': wxData.timeStamp, // 时间戳，自1970年以来的秒数 'nonceStr': wxData.nonceStr, // 随机串 'package': wxData.prepayId, // 统一订单号 'signType': 'MD5', // 微信签名方式： 'paySign': wxData.paySign // 支付签名 &#125;, function(res) &#123; if (res.err_msg === 'get_brand_wcpay_request:ok') &#123; // 微信支付成功 回调 success(); &#125; else &#123; // 这里支付失败和支付取消统一处理//微信支付失败回调 error(); &#125; &#125;);&#125;// // 唤起微信方法export function callWxPay(a, success, error) &#123; wxData = a; if (typeof WeixinJSBridge === 'undefined') &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', jsApiCall, false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', jsApiCall); document.attachEvent('onWeixinJSBridgeReady', jsApiCall); &#125; &#125; else &#123; jsApiCall(success, error); &#125;&#125; 六. 如何使用 第一步 123456789101112// 点击支付按钮 调用接口获取appId // 使用window.location.replace 方法打开微信新页面获取 code// 此时微信回打开一个页面 然后会回到当前页面handleGoPay() &#123; this.$post(getWxAppId) .then((res) =&gt; &#123; if (res.status === 200) &#123; window.location.replace('https://open.weixin.qq.com/connect/oauth2/authorize?appid=' + res.appId + '&amp;redirect_uri=' + window.location.href + '&amp;response_type=code&amp;scope=snsapi_userinfo#wechat_redirect'); &#125; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;);&#125; 第二步 1234567891011121314151617181920//在发起支付的页面import &#123; getUrlParam, callWxPay &#125; from '@/plugins/wx-pay';export default &#123; mounted() &#123; // 调用方法获取 微信code this.wxCode = getUrlParam('code'); // 如果链接中含有code 则掉接口发起微信支付 if (this.wxCode) &#123; this.$post(fortDataChannel, &#123; formCode: '订单号', code: this.wxCode &#125;) .then((res) =&gt; &#123; if (res.status === 200) &#123; //res.data 是后台返回吊起微信支付的配置参数也就是wxData // 吊起支付后 关闭支付后执行的函数 callWxPay(res.data, () =&gt; &#123; this.$router.replace('/success'); &#125;, () =&gt; &#123; this.$router.replace('/error'); &#125;); &#125; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125; &#125;,&#125;]]></content>
      <categories>
        <category>Nuxt</category>
      </categories>
      <tags>
        <tag>nuxt</tag>
        <tag>微信</tag>
        <tag>分享</tag>
        <tag>支付</tag>
        <tag>微信分享</tag>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React之旅一]]></title>
    <url>%2Fkms-123%2FReact%E4%B9%8B%E6%97%85-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一.引子一个优秀的程序员不会局限于一种语言一个优秀的前端攻城狮不会局限于一种框架何况它还那么的强大一开始还是我是拒绝学习的 直到我司来了一位10年开发经验的大佬…向大佬学习！！！ 二.什么是reactReact是Facebook开发的一款JS库。React一般被用来作为MVC中的V层，它不依赖其他任何的库，因此开发中，可以与任何其他的库集成使用，包括Jquery、Backbone等。它可以在浏览器端运行，也可以通过nodejs在服务端渲染。React的思想非常独特，性能出众，可以写出重复代码少，逻辑清晰的前端代码。React的语法是jsx，通过使用这种语法，可以在react代码中直接混合使用js和html来编写代码，这样代码的逻辑就非常清晰，当然也意味着，需要将jsx代码编译成普通的javascript代码，才能在浏览器中运行，这个过程根据实际项目情况，可以选择多种不同的思路，或者在服务器端通过webpack进行编译。React是MVC框架使用数据驱动视图，当数据发生变化视图发生变化。若只是修改视图，数据并不会改变。Vue是MVVM框架。双向数据绑定，当数据发生变化视图发生变化。视图发生变化，数据也会随之改变React官网:https://zh-hans.reactjs.org/ 三.React脚手架 什么是react脚手架：FaceBook官方发布了一个无需配置，用于快速构建开发环境的脚手架工(create-react-app) 如何使用： 使用npm自带的npx安装(官方推荐，本地就不会下载create-react-app，随用随创) 123npx create-react-app project-nameprojectNamecd project-namenpm run start 全局安装脚手架创建 123456&lt;!-- 全局安装脚手架 --&gt;npm install -g create-react-app&lt;!-- 在指定的目录下创建你的新项目 --&gt;create-react-app project-namecd project-namenpm run start 注意：React帮我们将艮长的配置文件全部隐藏了。只能通过eject命令将所有的配置文件暴露出来，但请牢记这个操作是不可逆的。 1npm run eject 四.React中的虚拟Dom是什么？React中是如何通过ReactDOM.render()方法生成Dom节点的呢？ 什么是JSX？JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。可以理解为在JS中编写与XML类似的语言,一种定义带属性树结构（DOM结构）的语法，它的目的不是要在浏览器或者引擎中实现，它的目的是通过各种编译器将这些标记编译成标准的JS语言。你可以将HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 1234567render() &#123; return ( &lt;div&gt; &lt;h1 className="text-style" &gt;Hello, world!&lt;/h1&gt; &lt;/div&gt; );&#125; JSX将原本HTML与javaScript混写的代码通过 babel-preset-react-app 插件将代码转换成React.createElement(elementn,props,[…children])可以创建的方式 他是如何转换的？看上面那部分代码，我们将它放在babeljs上查看下 12345&lt;!-- 转换后的结果 --&gt;React.createElement("div", null, React.createElement("h1", &#123; className: "text-style", name: 1212&#125;, "Hello, world!")); React.createElement(elementn,props,[…children])解析element: 要创建的HTML元素 也就是我们常说的HTML标签 (这个是必须的,还可以为函数组件/类组件) props: 是在这个标签上的所有的属性 比如上面的列子中含有的 className 和 name(这是必须的，没有参数则为Null) children： 这个参数是标签中是否含有文本或标签 什么都没有：&apos;&apos; 就是空 仅含有文本：呈现方式为 &apos;你好世界&apos;; 仅含有标签:呈现方式为{className:&apos;border-red&apos;} 含有文本+标签(多个)：呈现方式为[&apos;你好世界&apos;，{className:&apos;border-red&apos;}，{···}] React何时创建的虚拟DOM执行React.createElement(elementn,props,[…children])就会创建虚拟DOM对象了。我们来看看是什么样子的可以看出type属性就是我们的第一个参数props就是我们attrchildren就是我们嵌套的内容了 React.render(JSX,document.getElementById(‘root’))这一切的努力都是为了回到原点。使用React.render()方法将虚拟DOM对象挂在节点上 什么是纯函数 相同的输入 一定会返回相同的输出 永远 不会修改传入的参数值\ 五.JSX语法细节 JSX如何解析html文本使用dangerouslySetInnerHTML 属性 但这是危险的 1&lt;span dangerouslySetInnerHTML=&#123;&#123;__html:item&#125;&#125;&gt;&lt;/span&gt; JSX中添加CSS属性class 要使用className 属性 1&lt;input type="text" className="input" /&gt; JSXlabel的坑 要使用htmlFor 关联 12&lt;label htmlFor=&quot;inse&quot;&gt;输入内容&lt;/label&gt;&lt;input id=&quot;inse&quot; className=&quot;input&quot;/&gt; 六.知识点 setState：React中修改数据不能直接修改 要使用setState方法 这个分两种方式 setState修改数据是异步的 第一种方法 123this.setState = &#123; xxx: 123&#125; 第二种方法123456789this.setState((prevState)=&gt;&#123; return &#123; status:true &#125;&#125;,()=&gt;&#123; // 在这里可以获取到this.setState修改后的数据&#125;)this.setState(异步获取 可能获取不到修改后的值) 事件绑定 1234567891011121314151617181920212223242526272829303132333435363738constructor() &#123; super() this.state = &#123; inputValue:'XXX', &#125; this.handleAdd = this.handleAdd.bind(this)&#125;// 第一种handleAdd()&#123; console.log(this) // 没有this.handleAdd = this.handleAdd.bind(this) 会获取不到this &#125;// 第二种 推荐写法chnageInputValue = (e) =&gt; &#123; console.log(e); this.setState(&#123; inputValue:e.target.value &#125;)&#125;handleKeyUp = (e) =&gt; &#123; if (e.keyCode === 13) &#123; this.handleClickAdd() &#125;&#125;render() &#123; return ( &lt;&gt; &lt;input type="text" onChange=&#123;this.chnageInputValue&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;&#123;this.props.btnText&#125;&lt;/button&gt; // 添加参数 &lt;input type="text" onChange=&#123;()=&gt;&#123;this.chnageInputValueCanShu(传递的参数)&#125;&#125; value=&#123;this.state.inputValue&#125; /&gt; // 绑定键盘事件 &lt;input type="text" onChange=&#123;this.chnageInputValue&#125; onKeyUp=&#123;this.handleKeyUp&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;/&gt; )&#125; Ref引入 createRef 123456789101112131415161718192021222324252627282930313233import React, &#123; Component, createRef&#125; from 'react'constructor() &#123; super() this.state = &#123; inputValue:'XXX', &#125;&#125;chnageInputValue = (e) =&gt; &#123; console.log(e); this.setState(&#123; inputValue:e.target.value &#125;)&#125;handleClickAdd = () =&gt; &#123; this.props.addTodo(this.state.inputValue) this.setState(&#123; inputValue:'' &#125;, () =&gt; &#123; this.inputRef.current.focus(); &#125;)&#125;inputRef = createRef() // 点击添加按钮 鼠标光标自动回到input上render() &#123; return ( &lt;&gt; &lt;input type="text" onChange=&#123;this.chnageInputValue&#125; value=&#123;this.state.inputValue&#125; ref=&#123;this.inputRef&#125;/&gt; &lt;button onClick=&#123;this.handleClickAdd&#125;&gt;&#123;this.props.btnText&#125;&lt;/button&gt; &lt;/&gt; )&#125; 使用prop-types校验参数类型: 子组件中效验父组件传递的参数是否符合规范 安装 prop-types 1npm install -S prop-types 如何使用 PropTypes 12345678910import PropTypes from 'prop-types'static propTypes = &#123; todoList: PropTypes.arrayOf(PropTypes.object)// 验证参数是数组 里面的每一项是对象 todoList:PropTypes.arrayOf(PropTypes.shape(&#123; id:PropTypes.number.isRequired, title:PropTypes.string.isRequired, isCompleted:PropTypes.bool.isRequired, &#125;)).isRequired// // 验证参数是数组 每一项是对象 对象的每一个参数类型&#125; 1234567//组件名.propTypesTodoItem.propTypes = &#123; // 属性值 item: PropTypes.oneOfType([PropTypes.string,PropTypes.number]),// 可以使字符串 也可以是number itemDelete: PropTypes.func, index:PropTypes.number&#125; defaultProps的使用 123456TodoItem.propTypes = &#123; test:PropTypes.string.isRequired //isRequired:父组件必须传递给我&#125;TodoItem.defaultProps = &#123; test:&apos;Hello World&apos;&#125; react 父组件传值给子组件 1234567891011121314151617181920212223// 父组件 &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; // 在子组件上定义自定义属性 并传递参数 return &lt;TodoItem item=&#123;item&#125; index=&#123;index&#125; key=&#123;index&#125; /&gt; &#125;) &#125; &lt;/ul&gt; // 子组件 通过this.props.属性取值 &lt;li &gt; &lt;span dangerouslySetInnerHTML=&#123;&#123;__html:this.props.item&#125;&#125;&gt;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123; this.handleItemDelete(this.props.index) &#125;&#125;&gt;删除&lt;/button&gt; &lt;/li&gt; // 子组件也可以使用对象结构的方式 获取 render() &#123; let &#123; item &#125; = this.props return ( &lt;li &gt; &lt;span dangerouslySetInnerHTML=&#123;&#123;__html:item&#125;&#125;&gt;&lt;/span&gt; &lt;/li&gt; ) &#125; react 子组件如何修改父组件中state中的值 12345678910111213// 在父组件中的子组件上添加属性 传递方法 itemDelete方法&lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return &lt;TodoItem itemDelete=&#123;this.handleItemDelete&#125; item=&#123;item&#125; index=&#123;index&#125; key=&#123;index&#125; /&gt; &#125;) &#125;&lt;/ul&gt;// 在子组件中使用this.props.itemDelete调用父组件的方法handleItemDelete = () =&gt; &#123; this.props.itemDelete(this.props.index);&#125; React中的生命周期函数：指某一时刻组件会自动调用执行函数 componentWillMount：在组件即将挂载到页面的时刻自动调用 componentDidMount: 在组件挂载到页面的时刻自动调用 shouldComponentUpdate(nextProps,nextState)：在组件更新之前或自动调用 需要返回boolean值 return true 更新组件 false 不更新组件 nextProps：更新后(下一次)的props的值 nextState：下一次state的值使用场景：在父组件中输入框中更新数据 会使子组件render自动更新 设置false 强制不更新 只在props的值变更影响子组件渲染的时候更新12345678shouldComponentUpdate(nextProps, nextState) &#123; // 下一次的item的值与当前的item的是否相等 不相等更新子组件 相等不更新 if (nextProps.item !== this.props.item) &#123; return true &#125; else &#123; return false &#125;&#125; componentWillUpdate：shouldComponentUpdate执行后执行 在render执行前执行 componentDidUpdate：组件更新完成之后 执行 componentWillReceiveProps：当一个组件从父组件接收参数 只要父组件render执行了 该函数就会执行 若当前子组件第一次现在在父组件中 改钩子不会执行 若当前子组件已经在父组件中 该钩子会执行 componentWillUnmount：组件销毁前的钩子 React中如何使用动画 使用css写动画 12345678910111213141516171819202122232425262728293031jsxhandleToggle = () =&gt; &#123; this.setState(() =&gt; (&#123; show:!this.state.show &#125;))&#125;render() &#123; return ( &lt;&gt; &lt;div className=&#123;this.state.show ? 'show' : 'hied'&#125;&gt;Hello Wrold&lt;/div&gt; &lt;button onClick=&#123;this.handleToggle&#125;&gt;toggle&lt;/button&gt; &lt;/&gt; )&#125;css.show&#123; animation: show-item 2s ease-in forwards;&#125;.hied&#123; animation: hide-item 2s ease-in forwards;&#125;@keyframes show-item&#123; 0% &#123; color: pink; opacity:0; &#125; 50% &#123; color: blue; opacity: .5; &#125; 100% &#123; color: red; opacity: 1; &#125;&#125;@keyframes hide-item&#123; 0% &#123; color: pink; opacity: 1; &#125; 50% &#123; color: blue; opacity: .5; &#125; 100% &#123; color: red; opacity: 0; &#125;&#125; 使用react-transition-group 做动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621. 安装 react-transition-group 2. npm install react-transition-group3. 使用 import &#123; CSSTransition,TransitionGroup &#125; from "react-transition-group";// 引入组件// CSSTransition 只能对于单个元素 单个组件// TransitionGroup 多个组件 用TransitionGroup 包裹多个CSSTransitionimport './index.css'// 引入样式&lt;TransitionGroup&gt; this.state.list.map((item,index)=&gt;&#123; return ( &lt;CSSTransition key=&#123;index&#125; // true 执行入场动画 false执行出场动画 in=&#123;this.state.show&#125; // 设置动画执行时间 timeout=&#123;2000&#125; // 动画库的名字 自定义 classNames="fade" // 动画结束后是否显示Dom元素 unmountOnExit // 页面加载出来 是否加载动画 appear=&#123;true&#125; // enter”或“ appear”类后立即触发的回调。 入场动画开始之前 执行结束 onEnter=&#123;() =&gt; &#123; console.log(1111); &#125;&#125; // enter-active”或“ appear-active”类后立即触发的回调。 /* 入场动画开始后 入场动画执行中 还没有结束 时调用 onEntering=&#123;() =&gt; &#123; console.log(22222); &#125;&#125; // 入场动画完全 结束后调用 onEntered=&#123;() =&gt; &#123; console.log(3333); &#125;&#125; // 出场动画开始前调用 onExit=&#123;() =&gt; &#123; console.log(4444); &#125;&#125; // 出场动画开始后 调用 动画还在执行中 onExiting=&#123;() =&gt; &#123; console.log(55555); &#125;&#125; // 出场动画执行完后 调用 onExited=&#123;() =&gt; &#123; console.log(666); &#125;&#125; &gt; &lt;div &gt;Hello Wrold&lt;/div&gt; &lt;/CSSTransition&gt; ) &#125;)&lt;/TransitionGroup&gt;css/* 入场动画开始前 *//* fade-appear 页面加载就会执行 配合appear属性 */.fade-enter, .fade-appear&#123; opacity: 0; color: blue; &#125;/* 入场动画开始后 入场动画执行中 还没有结束 *//* fade-appear-active 页面加载就会执行 配合appear属性 */.fade-enter-active, .fade-appear-active&#123; opacity: 1; color: blue; transition:all 2s ease-in; &#125;/* 入场动画结束后 *//* fade-appear-done 页面加载就会执行 配合appear属性 */.fade-enter-done, .fade-appear-done&#123; opacity: 1; color: blue; &#125;/* 出场动画前 */.fade-exit&#123; opacity: 1; &#125;/* 出场动画后 出场动画执行中 */.fade-exit-active&#123; opacity: 0; transition:all 2s ease-in; &#125;/* 出场动画后 */.fade-exit-done&#123; opacity: 0; &#125; 七. UI组件和容器组件&amp;无状态组件 什么是UI：只负责页面渲染 不负责页面操作 什么书容器组件：只负责页面逻辑操作，不负责UI渲染 什么是无状态组件：当组件中只有render函数的时候 则可以更改此组件为无状态组件 好处：性能高八. 管理页面css文件 安装styled-components 1npm i styled-components 使用 123456789101112131415 //在组件文件夹中新建style.js === style.css // 添加全局样式文件import &#123; createGlobalStyle &#125; from 'styled-components'export const GlobalStyle = createGlobalStyle` body&#123; background-color:red; &#125; ` // 组件中 import &#123; GlobalStyle &#125; from './style.js'; ReactDOM.render( &lt;&gt; &lt;GlobalStyle /&gt; &lt;App &gt; &lt;/App&gt; &lt;/&gt; , document.getElementById('root')); 九.添加PC端统一样式文件 reset.css123456789101112131415161718192021222324252627282930313233343536html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: ''; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;; 注： 命令式开发：即jQuery直接操作DOM 声明式开发：react 根据数据显示页面 react中的数据是单项数据流 state，prpos 的值发生改变 render函数就会重新渲染一次神头鬼脸·魔法写法123456789&lt;List style=&#123;&#123;width:'300px'&#125;&#125; bordered dataSource=&#123;data&#125; renderItem=&#123;(item,index) =&gt; ( &lt;List.Item onClick=&#123;(index) =&gt; &#123; handleDeleteItem(index) &#125;&#125; &gt;&#123;item&#125;&lt;/List.Item&gt; // 获取不到index的值 因为click 的第一个参数就当前Dom 对象 &lt;List.Item onClick=&#123;()=&gt;handleDeleteItem(index)&#125; &gt;&#123;item&#125;&lt;/List.Item&gt; // 可以获取到 ) &#125;/&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>学习</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue权限动态路由菜单]]></title>
    <url>%2Fkms-123%2FVue%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%8F%9C%E5%8D%95.html</url>
    <content type="text"><![CDATA[一. 什么是权限动态路由？权限动态路由：是用户登录的时候，根据用户信息，判断用户角色，动态的加载当前角色的路由。一般管理后台用到的比较多。 二. 预先了解。 Vue-Router ====&gt; beforeEach 是什么？ Router.berforeEach是什么:路由守卫之全局前置守卫，每次切换页面的时候都会经过此页面，他接受三个参数，分别是to： 即将要进入的目标 路由对象{path:’/‘,omponent:’’}from: 当前导航正要离开的路由next: 回调钩子，逻辑的最后一定要调用，不然页面会卡住，next()方法还可以传递路由参数进行路由重定向 Vue-Router ====&gt; addRouter 是什么？ addRouter：动态添加更多的路由规则。参数必须是一个符合 router 选项要求的数组。 一般前端的路由表写死了，就无法添加了 ，通过addRouter方法可以动态的添加新的路由，当然你得确保有页面 不然会报错的。 Vuex 使用Vuex，存储后台根据权限返回来的路由表，并持久化存储。以保证页面刷新数据不会丢失，不频繁的请求权限路由表 element-ui 这个对照着官方文档撸传送门 三. 搭建布局页面(layout)，模块页面(vivew) 布局页面：在src/components目录下新建layout目录并添加以下组件,最后页面显示成右侧(文末附上git地址) 模块页面: 创建3个模块，添加7个页面2个模块登录后加载，一个模块本地合并登录后的一起加载 (project=&gt;本地路由，setting与video登陆后返回) 四. 添加路由添加路由模板文件(router.js) 和 环境路由模板路径处理文件模板文件用于本地化测试，本地化测试成功再使用接口请求 五. 使用Vuex在Vuex中设置路由变量,登录验证等;1234567891011121314151617181920212223242526272829303132333435import Vue from "vue";import Vuex from "vuex";import &#123; GET_SESSION_STORAGE, SET_SESSION_STORAGE &#125; from "@/utils/sessionStorage.js";Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; router: GET_SESSION_STORAGE("router") || [], // 用户权限路由列表 navRouter: GET_SESSION_STORAGE("navRouter") || [], // 从后台获取的导航栏路由 isLogin: GET_SESSION_STORAGE("login") || false // 判断用户是否登录 &#125;, getters: &#123; // 将本地路由与后台返回的路由结合, 渲染侧边栏组件 comRouter: state =&gt; state.router, // 后台返回的路由列表 comNavRouter: state =&gt; state.navRouter, comLogin: state =&gt; state.isLogin &#125;, mutations: &#123; SET_COM_LOGIN: (state, params) =&gt; &#123; SET_SESSION_STORAGE("login", params); state.isLogin = params; &#125;, // 修改路由列表 SET_ROUTER_CHANGE: (state, params) =&gt; &#123; SET_SESSION_STORAGE("router", params); state.router = params; &#125;, // 将本地路由与后台返回的路由结合, 渲染侧边栏组件 SET_NAV_ROUTER: (state, params) =&gt; &#123; SET_SESSION_STORAGE("navRouter", params); state.navRouter = params; &#125; &#125;&#125;); 六. 登录保存，路由信息。这时候我们创建登录页面当我们点击登录的时候 模拟从后台获取到的路由数据 navRouter 并保存在Vuex中12345678910111213141516171819202122232425262728293031323334353637// src/views/login&lt;!--登录页面 --&gt;&lt;template&gt; &lt;div class="wrap"&gt; &lt;div class="login "&gt; &lt;el-input v-model="input" placeholder="请输入账号"&gt;&lt;/el-input&gt; &lt;el-input v-model="pwad" placeholder="请输入密码"&gt;&lt;/el-input&gt; &lt;el-button @click="handleSubmit"&gt;登录&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import navRouter from "@/router/router.js";import &#123; mapMutations &#125; from "vuex";export default &#123; data () &#123; return &#123; input: "", pwad: "" &#125;; &#125;, methods: &#123; // 用户登录 handleSubmit () &#123; // 登录的时候将路由写入navRouter this.SET_NAV_ROUTER(navRouter); this.SET_COM_LOGIN(true); this.$router.push("/"); &#125;, ...mapMutations(&#123; SET_NAV_ROUTER: "SET_NAV_ROUTER", SET_COM_LOGIN: "SET_COM_LOGIN" &#125;) &#125;&#125;;&lt;/script&gt; 七. 登录成功 处理路由数据，并将最终的路由保存在Vuex中在src目录下添加路由动态加载js(promission.js =&gt; 权限加载js)生成最后的侧边栏路由导航这里是重点，这里写了大量的注释就是方便大家可以看懂，这里看懂，就成功了一半了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import router from "./router/index";// Layout 是布局组件，不在后台返回，在文件里单独引入import Layout from "@/components/Layout/layout.vue";import Store from "./store.js";// 获取Vuex实例// 默认加载的路由，不需要后台返回的路由 可以在router文件夹中添加默认路由import defaultRouter from "@/router/defaultRouter.js";// process.env.NODE_ENV 根据不同的环境 加载不同的路由模板处理文件const _import = require("./router/config/_import_" + process.env.NODE_ENV);var getRouter; // 用来保存后台拿到的路由router.beforeEach((to, from, next) =&gt; &#123; // 判断 数据仓库中有没有 用户登录返回的路由列表 有 if (Store.getters.comNavRouter &amp;&amp; Store.getters.comNavRouter.length &gt; 0) &#123; if (!getRouter) &#123; // 判断有没有路由权限 没有 路由权限 重新请求|从Vuex中获取 getRouter = Store.getters.comNavRouter;// 拿到路由 routerGo(to, next);// 调用动态添加路由的方法 &#125; else &#123; // 判断有没有路由列表 有 允许进入下个这里是第二个beforeEach next(); &#125; &#125; else &#123; // 判断 数据仓库中有没有 用户登录返回的路由列表 没有 ===&gt;去登陆页 next(); &#125;&#125;);function routerGo (to, next) &#123; // 过滤路由 调用filterAsyncRouter 数据模板处理方法 返回Vue-router可以识别数据 getRouter = filterAsyncRouter(getRouter); // 动态添加所有的的路由 router.addRoutes(Store.getters.comRouter); // 调用next()放行 next(&#123; ...to, replace: true &#125;);&#125;// 遍历后台传来的路由字符串，转换为组件对象 递归方法function filterAsyncRouter (asyncRouterMap) &#123; const accessedRouters = asyncRouterMap.filter(route =&gt; &#123; if (route.component) &#123; // 路由有component if (route.component === "Layout") &#123; // 判断路由是Layout 布局组件，将上方引用的Layout布局组件放进去 route.component = Layout; &#125; else &#123; // 路由不是Layout组件 二级也main route.component = _import(route.component); &#125; &#125; // 判断当前的路由对象中是否含有children 有再次调用本方法 递归调用 直到没有 if (route.children &amp;&amp; route.children.length) &#123; route.children = filterAsyncRouter(route.children); &#125; return true; &#125;); Store.commit("SET_ROUTER_CHANGE", defaultRouter.concat(Store.getters.comNavRouter));// 合并整个路由表(默认路由+后台返回的路由) 保存在Vuex中 return accessedRouters;&#125; 八. 最后在Nva组件中渲染路由列表有想法的同学可以将侧边栏组件设置为递归组件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- Layout侧边栏组件页面 --&gt;&lt;template&gt; &lt;el-menu default-active="" class="el-menu-vertical-demo" router @open="handleOpen" @close="handleClose" background-color="#545c64" text-color="#fff" active-text-color="#ffd04b"&gt; &lt;!-- 一个模块 --&gt; &lt;el-submenu :index="value.path" v-for="(value,index) in comRouter" :key="'comRouter'+index"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;value.meta.title&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;!-- 一个模块的每个组成页 --&gt; &lt;el-menu-item-group v-for="(item,i) in value.children" :key="'children'+i"&gt; &lt;el-menu-item :index="value.path+'/'+item.path"&gt;&#123;&#123;item.meta.text&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from "vuex";export default &#123; methods: &#123; handleOpen (key, keyPath) &#123; console.log(key, keyPath); &#125;, handleClose (key, keyPath) &#123; console.log(key, keyPath); &#125; &#125;, computed: &#123; ...mapGetters(&#123; comRouter: "comRouter" &#125;) &#125;&#125;;&lt;/script&gt;&lt;style scoped lang="scss"&gt;.el-menu-vertical-demo&#123; width: 100%;&#125;&lt;/style&gt; 九. 最后的演示效果+Git地址GitHub地址GitHub：https://github.com/kemaosen/vue-admin 十. 常见错误 Uncaught (in promise) undefined 1运行 npm install npm i vue-router@3.0 -S 报错：Cannot find module ‘xxx/xxx/xx.vue’多半是后台返回的数据与项目的文件名不一致，本地找到到’xxx/xx/xx/xx.vue’这个文件，和后台协调好数据不要写错注意大小写 asyncRouterMap.filter is not a function这种xxx.filter不是一个方法 filter是数组的API ，换句话说只允许数组调用Array.filter.全局搜索asyncRouterMap这个参数(好吧 他就在promission.js中) 在filterAsyncRouter方法中把参数asyncRouterMap打印出来看看是不是数组 不是逐步向上推演代码找到问题，并解决他。 为什么刷新后，页面没有重置？登录后数据存在session中，不关闭当前对话框数据就会一直存在浏览器中，可以清除浏览器缓存，或点击头部退出按钮.清空登录数据。十一. 参考Vue动态菜单(路由)的实现方案(beforeEach+addRoutes+elementUI)Vue 动态路由的实现(后台传递路由，前端拿到并生成侧边栏)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>权限</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Cli3.0脚手架搭建]]></title>
    <url>%2Fkms-123%2FVue-Cli3-0%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一. 什么是Vue-Cli？Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，也就是我们通常说的Vue框架。 二. 安装与卸载Vue-Cli Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。所以请各位查看下自己的node版本是否满足打开命令行输入 1node -v 查看自己是否安装了Vue-Cli脚手架打开命令行输入(注意是大写V) 1vue -V 如果你的版本不是3.0+ 请卸载当前系统的Vue-Cli 在命令行输入 12345npm uninstall vue-cli -g # ORyarn global remove @vue/cli 全局安装Vue-Cli3.0在命令行输入 12345npm install -g @vue/cli# ORyarn global add @vue/cli 三. 创建项目 自定义文件夹，在当前文件目录下打开命令行(按住Shift + 右键 选择)输入 1vue create you-project 这时候我们面临选择 第一个选项是博主上次创建保存下来的配置 第二个选项是Vue-Cli提供的默认配置，只包含一些基本的东西 第三个是自定义配置 所以我们选第三个 选择Vue-Cli为开发者提供的8个功能特性 使用键盘上下键在特性选项之间切换 空格选中按下回车 预处理语言与ESLint的选择按下回车 询问：Save this as a preset for future projects?是否保存本次创建项目的配置===》看个人喜好 看到这个界面基本上你就成功了根据提示 在当前的命令行输入 123cd vue-threenpm run serve 打开浏览器在地址栏输入 http://localhost:8080/ 看到这个界面你已经完成了Vue框架的搭建了 四. vue.config.jsVue-Cli3.0 搭建的框架相比Vue-Cli2.0搭建的框架减少了二个文件目录分别是 build目录 和 config目录也就没有了 webpack.base.config.js、webpack.dev.config.js 、webpack.prod.config.js 等配置文件。因为3.0的Cli将大多的配置已经配置好了，它们秉承的是“约定大于配置”思想，简单说就是”能不配置的就不配置，你就按照我的方式来，也不要去争论这个好不好，快速进行业务开发才是正经事”. 它们不建议你去配置，但也不会拦着你去配置 如何修改webpack配置在项目的根目录下(与src同级)创建 vue.config.js,这里附上一个配置说明根据需要自行修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// vue.config.jsmodule.exports = &#123; // 项目部署的基本路径 // 默认假设你的应用将会部署在域名的根部 // 比如，https://www.vue-cli.com/ // 如果你的应用是部署在一个子路径下，那么你需要在这里指定子路径，比如，如果你部署在 https://www.my-vue.com/my-app/; 那么将这个值改为 “/my-app/” // 默认静态文件引用目录 为/ publicPath: &apos;./&apos;, // 将构建好的文件输出到哪里 当运行 vue-cli-service build 时生成的生产环境构建文件的目录。注意目标目录在构建之前会被清除 (构建时传入 --no-clean 可关闭该行为)。 outputDir: &apos;dist&apos;, // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 assetsDir: &apos;./&apos;, // 是否在开发环境下通过 eslint-loader 在每次保存时 lint 代码。这个值会在 @vue/cli-plugin-eslint 被安装之后生效。 // 设置为 true 时，eslint-loader 会将 lint 错误输出为编译警告。默认情况下，警告仅仅会被输出到命令行，且不会使得编译失败。 // 如果你希望让 lint 错误在开发时直接显示在浏览器中，你可以使用 lintOnSave: &apos;error&apos;。这会强制 eslint-loader 将 lint 错误输出为编译错误，同时也意味着 lint 错误将会导致编译失败。 lintOnSave: true, // 是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。 runtimeCompiler: false, // 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 transpileDependencies: [], // 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 productionSourceMap: false, // 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: () =&gt; &#123;&#125;, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 parallel: require(&apos;os&apos;).cpus().length &gt; 1, // 向 PWA 插件传递选项。 // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // 所有 webpack-dev-server 的选项都支持。注意：有些值像 host、port 和 https 可能会被命令行参数覆写。 // 有些值像 publicPath 和 historyApiFallback 不应该被修改，因为它们需要和开发服务器的 publicPath 同步以保障正常的工作。 // 代理配置 devServer: &#123; host: &apos;0.0.0.0&apos;, port: 8080, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: true // 配置自动启动浏览器 open: &apos;Google Chrome&apos;-默认启动谷歌 // proxy: &apos;http://localhost:9000&apos; // 配置跨域处理,只有一个代理 // 配置多个代理 // proxy: &#123; // &apos;/api&apos;: &#123; // target: &apos;https://way.jd.com&apos;, // 目标主机 // ws: true, // 代理的WebSockets // changeOrigin: true, // 需要虚拟主机站点 // pathRewrite: &#123; // &apos;^/api&apos;: &apos;&apos; // &#125; // &#125; // &#125; &#125;, // 第三方插件选项 // 这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项。 pluginOptions: &#123;&#125;&#125;;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode+ESlint自动修复代码格式错误]]></title>
    <url>%2Fkms-123%2FVSCode%2BESlint%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[一. 开篇自从知道有ESlint这个东西就一直想弄，最近搭建了Vue-Cli3.0的框架并引入ESLint折腾来折腾去，终于是完成了 先看下效果Vu-Cli3.0搭建框架传送门 二. 什么是ESlintESLint属于一种QA工具，是一个ECMAScript/JavaScript语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 三. 为什么要使用ESLint 团队合作每个人都是独立的，每个人的代码风格也是独立的，开发出来的代码就像一锅粥。A程序员不喜欢B程序员的，B程序员看不惯Ade； 独特的人独特的代码风格，各种代码不规范。想修改又不是自己写的，不改看着又难受； 减少低级Bug的产出，比如代码最后必须分号结尾，判断使用’===’； 没规矩不成方圆，便于自己养成良好的代码风格，不要在让自己的代码风格野蛮生长了； .. 四. VSCode + ESLint + Standard 统一前端代码规范 Standard JavaScript标准代码风格检查 他的详细配置有详细规则 上次我们搭建了3.0的框架使用的就是prettier本来想使用这个规则库，后来写博客发现大家对Prettier有着很高的呼声，自己尝试的换成了prettier规则库发现很多的规则VSCode没有提示，整体的风格与我想象的相差太多。最后还是采用Standard(创建项目的时候ESLint可以直接选择Standard) 创建.editorconfig文件 123456//可以帮助开发者在不同的编辑器和 IDE 之间定义和维护一致的代码风格。[*.&#123;js,jsx,ts,tsx,vue&#125;]indent_style = space // 采用空格缩进indent_size = 4 // 采用四空格缩进trim_trailing_whitespace = trueinsert_final_newline = true 创建ESlint忽略文件 .eslintignore 12// 啥也没有 // 大家自行添加与git 的忽略文件格式是一样的 安装Standard语法检查插件 1npm install @vue/eslint-config-standard -D 修改.eslintrc.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071module.exports = &#123; root: true, // 这些环境并不是互斥的，所以你可以同时定义多个 env: &#123; node: true, browser: true, jquery: true, commonjs: true, es6: true &#125;, 'extends': [ 'plugin:vue/essential', '@vue/standard' ], rules: &#123; 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', // 使用4空格缩进 'indent': [ 'error', 4 ], 'vue/script-indent': [ 'error', 4 ], // 行尾必须使用分号结束 'semi': [ 'error', 'always' ], // 分号前后的空格规则 'semi-spacing': 0, // 禁止行首出现分号 'semi-style': [ 2, 'last' ], // imports 必须排好序 // @off 没必要限制 'sort-imports': 0, // 单行注释必须写在前一行还是行尾 // @off 不限制 'line-comment-position': [ 'off' ], // 可以自定义行后添加注释 保存时候不会更改注释的位置 显示bannerList: '', // 获取banner列表 关闭规则 显示为这样bannerList: '',// 获取banner列表 'no-multi-spaces': [ 'error', &#123; ignoreEOLComments: true &#125; ], // 注释前后是否要空一行 // @off 不限制 'lines-around-comment': 0, // 必须使用 jsdoc 风格的注释 // @off 暂不考虑开启 'require-jsdoc': 0, // 允许使用 三目运算 'no-unused-expressions': [ 'error', &#123; 'allowShortCircuit': true, 'allowTernary': true &#125; ], 'no-useless-escape': 0, // 允许数组中包含对象 俩边保留空格subjectName: [ &#123; validator: text, trigger: 'blur' &#125; ], 'array-bracket-spacing': [ 'error', 'always' ], // 必须采用全等 'eqeqeq': [ 'error', 'always', &#123; 'null': 'ignore' &#125; ], // 禁止而外的分号 'no-extra-semi': 2, // 禁止使用 label // @off 禁止了将很难 break 多重循环和多重 switch 'no-labels': 0, // 禁止在return中赋值 'no-return-assign': [ 'off' ], // 禁止使用 tabs // @off 不限制 'no-tabs': 0, // 禁止重复声明 'no-redeclare': 2, // jsx 语法中，属性的值必须使用双引号 'jsx-quotes': [2, 'prefer-double'], // 字符串必须使用双引号"" 'quotes': [2, 'double', &#123; 'avoidEscape': true, // 允许包含单引号的字符串使用双引号 'allowTemplateLiterals': true, // 允许使用模板字符串 &#125;], &#125;, parserOptions: &#123; parser: 'babel-eslint' &#125;&#125;; 当然这些规则可能不适合你 所以对有些规则大家可以自行更改;规则目录 打开VSCode =&gt; 文件 =&gt; 首选项 =&gt; 设置 =&gt; setting 向下滚动 找到如图所示的setting.json 点击在右侧添加 123456789101112131415// Vuetemplate文件缩进不是4空格问题"[vue]": &#123; "editor.insertSpaces": true, "editor.tabSize": 4,&#125;,// ESlint 代码修复"eslint.validate": [ "javascript", "javascriptreact", "html", "vue-html", &#123; "language": "vue", "autoFix": true &#125;],"vetur.format.options.tabSize": 4,"vetur.format.options.useTabs": true, 安装ESlint插件 和 Vetur 最后的效果 有些错误无法一次修改完成，请尝试再次（多次）Ctrl+S 再手动修复 为什么不能100%修复 有些规则还是需要自己手动优化比如 禁止声明了变量不使用，当然修改规则忽略它 import引用使用的路径不同无法合并 我开启了全等的判断 不允许使用 == &amp; != 更利于看到自己编程风格的缺陷 规则都是自己配置的觉得不好可以修改，但请不要将规则都设为’off’. 五. 如何修改规则？ 将鼠标放在代码有红色波浪线上面会提示规则报错的提示，复制报错的信息(无法复制的问题，鼠标选中不放手+Ctrl+c) 直接google搜索 找到这样的(左边英文，右边中文，有条件的同学建议选择英文的，没条件的同学也建议选择英文并使用谷歌自带的页面翻译功能) 使用提示功能自动打开规则页面 将鼠标放在代码有红色波浪线上面会提示规则报错的提示，选择快速修复 点击红色部分提示 根据里面的案列讲解自己手动修改， 1234567// 在.eslintrc.js的rules中添加规则配置rules:&#123; ··· // 打上备注 // 允许有声明了但未使用的变量 &quot;no-unused-vars&quot;: &quot;off&quot;,&#125; 六. 在Vue-Cli2.X版本使用 安装需要的第三方包 1npm install eslint-config-standard eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard -D 修改.eslintrc.js相比上面的.eslintrc.js 规则略微做了改动， 规则是死的，人是活的。自己不习惯请自行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081module.exports = &#123; root: true, // 这些环境并不是互斥的,所以你可以同时定义多个 env: &#123; node: true, browser: true, commonjs: true, es6: true &#125;, 'extends': [ 'standard', 'plugin:vue/essential', ], rules: &#123; 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', // 使用4空格缩进 'indent': [ 'error', 4 ], // 'vue/script-indent': [ 'error', 4 ], // 行尾必须使用分号结束 'semi': [ 'error', 'always' ], // 分号前后的空格规则 // @off 不限制 'semi-spacing': 0, // 禁止行首出现分号 'semi-style': [ 2, 'last' ], // imports 必须排好序 // @off 没必要限制 'sort-imports': 0, // 单行注释必须写在前一行还是行尾 // @off 不限制 'line-comment-position': [ 'off' ], // 可以自定义行后添加注释 保存时候不会更改注释的位置 显示bannerList: '', // 获取banner列表 关闭规则 显示为这样bannerList: '',// 获取banner列表 'no-multi-spaces': [ 'error', &#123; ignoreEOLComments: true &#125; ], // 注释前后是否要空一行 // @off 不限制 'lines-around-comment': 0, // 必须使用 jsdoc 风格的注释 // @off 暂不考虑开启 'require-jsdoc': 0, // 允许使用 三目运算 'no-unused-expressions': [ 'off', &#123; allowShortCircuit: true, allowTernary: true,allowTaggedTemplates:true &#125; ], 'no-useless-escape': 0, // 允许数组中包含对象 俩边保留空格subjectName: [ &#123; validator: text, trigger: 'blur' &#125; ], 'array-bracket-spacing': [ 'error', 'always' ], // 必须采用全等 'eqeqeq': [ 'error', 'always', &#123; 'null': 'ignore' &#125; ], // 禁止而外的分号 'no-extra-semi': 2, // 禁止使用 label // @off 禁止了将很难 break 多重循环和多重 switch 'no-labels': 0, // 禁止在return中赋值 'no-return-assign': [ 'off' ], // 禁止使用 tabs // @off 不限制 'no-tabs': 0, // 禁止重复声明 'no-redeclare': 2, 'no-unused-vars': [ 'error', &#123; vars: 'all', args: 'none', ignoreRestSiblings: false &#125;, ], // jsx 语法中,属性的值必须使用双引号 'jsx-quotes': [2, 'prefer-double'], // 字符串必须使用双引号"" 'quotes': [2, 'double', &#123; 'avoidEscape': true, // 允许包含单引号的字符串使用双引号 'allowTemplateLiterals': true, // 允许使用模板字符串 &#125;], // 关闭禁止使用异步函数作为Promise "no-async-promise-executor": 'off', // 关闭 禁止不必要的catch子句 "no-useless-catch": 'off', // 关闭禁止在正则表达式中出现空字符集 "no-misleading-character-class":'off' &#125;, parserOptions: &#123; parser: 'babel-eslint', &#125;&#125;; 七. 结束！]]></content>
      <categories>
        <category>Eslint</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>ESlint</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中添加Quill富文本自定义图片上传方法]]></title>
    <url>%2Fkms-123%2FVue%E4%B8%AD%E6%B7%BB%E5%8A%A0Quill%E5%AF%8C%E6%96%87%E6%9C%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[一. 在上一次Vue与Quill富文本的博客中我们已经说明了如何在Vue中使用Quill，并封装成组件，这里就不再次做说明了==&gt;传送门二. 为什么要做自定义上传，搞这么麻烦干什么？我司要求所有的图片上传都不允许通过后台处理，直接上传到阿里云对象存储。 三. 接下来我们来说下Vue中Quill如何添加自定义图片上传方法 开始我的表演 四. 先说组件自带的方法 源码12345678910111213141516171819202122232425262728293031323334353637383940editorOption: &#123; modules: &#123; ImageExtend: &#123; // 如果不作设置，即&#123;&#125; 则依然开启复制粘贴功能且以base64插入 name: 'fileFile', // 图片参数名 action:'www.img:8080', // 服务器地址, 如果action为空，则采用base64插入图片 size: 5, // 可选参数 图片大小，单位为M，1M = 1024kb // response 为一个函数用来获取服务器返回的具体图片地址 // 例如服务器返回&#123;code: 200; data:&#123; url: 'baidu.com'&#125;&#125; 则 return res.data.url response: (res) =&gt; &#123;// 图片上传成功或错误 回调方法 成功后将图片地址return出去 // 这里将后台返回的地址return出去 return res.filePath; &#125;, headers: (xhr) =&gt; &#123; // 可选参数 设置请求头部 // xhr.setRequestHeader('Content-Type','multipart/form-data') &#125;, sizeError: () =&gt; &#123;&#125;, // 图片超过大小的回调 start: () =&gt; &#123;&#125;, // 可选参数 自定义开始上传触发事件 end: () =&gt; &#123;&#125;, // 可选参数 自定义上传结束触发的事件，无论成功或者失败 error: () =&gt; &#123;&#125;, // 可选参数 上传失败触发的事件 success: () =&gt; &#123; &#125;, // 可选参数 上传成功触发的事件 change: (xhr, formData) =&gt; &#123; // xhr.setRequestHeader('myHeader','myValue') // formData.append('token', 'myToken') &#125; // 可选参数 每次选择图片触发，也可用来设置头部，但比headers多了一个参数，可设置formData &#125;, toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // if (value) &#123; // // 触发input框选择图片文件 // document.querySelector('.avatar-uploader input').click() // &#125; else &#123; // this.quill.format('image', false); // &#125; QuillWatch.emit(this.quill.id) &#125; &#125; &#125;, 你会发现整个ImageExtend 属性都是图片上传相关了以及各种事件的回调方法 ,大家根据注释配置相关的信息就好了toolbar 这个属性就像注释中说的那样// 如果不上传图片到服务器，此处不必配置到这里我们的使用后台的接口上传就完事了。 五. 使用Element-UI + Ali-oss直接上传到阿里云的对象存储 首先安装Ali-oss 1npm install ali-oss --save 创建oss上传的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115'use strict'/** * 时间日期格式化 * @param format * @returns &#123;*&#125; */ const dateFormat = function(dateObj, format) &#123; const date = &#123; 'M+': dateObj.getMonth() + 1, 'd+': dateObj.getDate(), 'h+': dateObj.getHours(), 'm+': dateObj.getMinutes(), 's+': dateObj.getSeconds(), 'q+': Math.floor((dateObj.getMonth() + 3) / 3), 'S+': dateObj.getMilliseconds() &#125; if (/(y+)/i.test(format)) &#123; format = format.replace(RegExp.$1, (dateObj.getFullYear() + '').substr(4 - RegExp.$1.length)) &#125; for (const k in date) &#123; if (new RegExp('(' + k + ')').test(format)) &#123; format = format.replace(RegExp.$1, RegExp.$1.length === 1 ? date[k] : ('00' + date[k]).substr(('' + date[k]).length)) &#125; &#125; return format&#125; var OSS = require('ali-oss')function getUUID() &#123; return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8); return v.toString(16); &#125;);&#125; export default &#123; /** * 创建随机字符串 * @param num * @returns &#123;string&#125; */ randomString(num) &#123; const chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] let res = '' for (let i = 0; i &lt; num; i++) &#123; var id = Math.ceil(Math.random() * 35) res += chars[id] &#125; return res &#125;, /** * 创建oss客户端对象 * @returns &#123;*&#125; */ createOssClient() &#123; return new Promise((resolve, reject) =&gt; &#123; const client = new OSS(&#123; region : '你自己的', accessKeyId : '你自己的', accessKeySecret : '你自己的', bucket : '你自己的' &#125;) resolve(client) &#125;) &#125;, /** * 文件上传 * @param option 参考csdn: https://blog.csdn.net/qq_27626333/article/details/81463139 */// 这里的我司的默认路径是test/ 有需要自行修改 ossUploadFile(option,folder='test/') &#123; const file = option.file const self = this return new Promise((resolve, reject) =&gt; &#123; const date = dateFormat(new Date(), 'yyyyMMdd') // 当前时间 const dateTime = dateFormat(new Date(), 'yyyyMMddhhmmss') // 当前时间 const randomStr = self.randomString(4)// 4位随机字符串 const extensionName = file.name.substr(file.name.indexOf('.')) // 文件扩展名 const fileName = folder + date + '/' + getUUID() + extensionName // 文件名字（相对于根目录的路径 + 文件名） // 执行上传 self.createOssClient().then(client =&gt; &#123; // 异步上传,返回数据 resolve(&#123; fileName: file.name, fileUrl: fileName &#125;) // 上传处理 // 分片上传文件 client.multipartUpload(fileName, file, &#123; progress: function(p) &#123; const e = &#123;&#125; e.percent = Math.floor(p * 100) // console.log('Progress: ' + p) option.onProgress(e) &#125; &#125;).then((val) =&gt; &#123; console.info(val) if (val.res.statusCode === 200) &#123; option.onSuccess(val) return val &#125; else &#123; option.onError('上传失败') &#125; &#125;, err =&gt; &#123; option.onError('上传失败') reject(err) &#125;) &#125;) &#125;) &#125;&#125; 注意文件中的这里需要你自己oss对象存储配置123456789101112131415/** * 创建oss客户端对象 * @returns &#123;*&#125; */createOssClient() &#123; return new Promise((resolve, reject) =&gt; &#123; const client = new OSS(&#123; region : '你自己的', accessKeyId : '你自己的', accessKeySecret : '你自己的', bucket : '你自己的' &#125;) resolve(client) &#125;)&#125;, 引入Element-UI 1npm install element-ui --save 在main.js中注入 1234// 引入element-ui 全局引入import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI); 在quill组件中添加上传组件并 稍微修改了下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;div class="upload" style='display:none'&gt; &lt;el-upload class="avatar-uploader" action ref="upload" name="img" :show-file-list="false" :auto-upload="true" :on-error="handleImageErrorQuill" :on-exceed="beyondFileQuill" :on-success="handleImageSuccessQuill" :http-request="fnUploadRequestQuill" :before-upload="beforeAvatarUploadQuill" :limit="3" multiple &gt; &lt;i class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; // 引入新的包 &lt;script&gt; const ossURL = '你的上传路径' import oss from "@/config/oss"; export default &#123;···&#125; &lt;/script&gt; // 在methods中添加方法 methods: &#123; // * 上传失败的回调 handleImageErrorQuill() &#123; this.$message(&#123; message: "上传失败", type: "error" &#125;); &#125;, // * 文件超出个数限制时的钩子beyondFileQuill(files, fileList) &#123; this.$message(&#123; message: "只能上传" + this.limit, type: "error" &#125;); &#125;, // * 上传成功 handleImageSuccessQuill(response, file, fileList) &#123; if (response) &#123; // 向富文本插入图片链接 let quill = this.$refs.myQuillEditor.quill; let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 // 获取光标 设置属性 图片链接 quill.insertEmbed(length, `image`, `$&#123;ossURL + response.name&#125;`); quill.setSelection(length + 1); // 调整光标到最后 &#125; &#125;, // * 自定义上传覆盖默认上传 async fnUploadRequestQuill(option) &#123; oss.ossUploadFile(option,'image/');&#125;, // * 上传前对图片进行验证beforeAvatarUploadQuill(file) &#123; const isJPG = file.type === "image/jpeg" || file.type === "image/png" || file.type === "image/gif"; const isLtM = file.size / 1024 / 1024 &lt; 20; if (!isJPG) &#123; this.$message.error("上传头像图片只能是 JPG，PNG，GIF 格式!"); &#125; if (!isLtM) &#123; this.$message.error("上传头像图片大小不能超过 20MB!"); &#125; return isJPG &amp;&amp; isLtM;&#125; &#125;, 再次修改editorOption(富文本配置参数) 这次我们只需要修改toolbar属性 ,别忘了 12345678910111213141516toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏 也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // 触发input框选择图片文件 if (value) &#123; // 这里触发的是 element-ui上传组件 console.log(11111111111111) document.querySelector('.avatar-uploader input').click() &#125; else &#123; this.quill.format('image', false); &#125; // QuillWatch.emit(this.quill.id) &#125; &#125;&#125;, 好了我们基本上就成功了！ 可以看出光标在哪里上传的图片就在那里，也没有报错，控制台打印的信息也都对。？？？那里有问题? 六. 多个富文本，添加图片报错 是时候该告诉你们真相了！真相只有一个，我的程序有问题······一开始我也不知道会有这样的问题，直到我司另一前端对付产品的需求一个页面需要二个富文本时。话不多说我们开始 先将刚刚有问题的代码贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;template&gt; &lt;div&gt; &lt;quill-editor v-model="context" ref="myQuillEditor" :options="editorOption" @input="$emit('update:value', $event)" &gt; &lt;/quill-editor&gt; &lt;div class="upload" style='display:none'&gt; &lt;el-upload class="avatar-uploader" action ref="upload" name="img" :show-file-list="false" :auto-upload="true" :on-error="handleImageErrorQuill" :on-exceed="beyondFileQuill" :on-success="handleImageSuccessQuill" :http-request="fnUploadRequestQuill" :before-upload="beforeAvatarUploadQuill" :limit="limit" multiple &gt; &lt;i class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const ossURL = 'http://lalalalalalala.aliyuncs.com/'import &#123;quillEditor, Quill&#125; from 'vue-quill-editor';import &#123;container, ImageExtend, QuillWatch,&#125; from 'quill-image-extend-module';import &#123;quillRedefine&#125; from 'vue-quill-editor-upload';import ImageResize from 'quill-image-resize-module';Quill.register('modules/ImageResize', ImageResize )Quill.register('modules/ImageExtend', ImageExtend);import oss from "@/config/oss";export default &#123; mounted () &#123; this.context = this.value; &#125;, props:&#123; value:&#123; type:String, &#125;, &#125;, data() &#123; return &#123; limit:3, context:'', // 富文本框参数设置 editorOption: &#123; modules: &#123; ImageExtend: &#123; // 如果不作设置，即&#123;&#125; 则依然开启复制粘贴功能且以base64插入 name: '', // 图片参数名 size: 5, // 可选参数 图片大小，单位为M，1M = 1024kb action:"", // 服务器地址, 如果action为空，则采用base64插入图片 // response 为一个函数用来获取服务器返回的具体图片地址 // 例如服务器返回&#123;code: 200; data:&#123; url: 'baidu.com'&#125;&#125; 则 return res.data.url response: (res) =&gt; &#123;// 图片上传成功或错误 回调方法 成功后将图片地址return出去 return res.filePath; &#125;, headers: (xhr) =&gt; &#123; // 可选参数 设置请求头部 // xhr.setRequestHeader('Content-Type','multipart/form-data') &#125;, sizeError: () =&gt; &#123;&#125;, // 图片超过大小的回调 start: () =&gt; &#123;&#125;, // 可选参数 自定义开始上传触发事件 end: () =&gt; &#123;&#125;, // 可选参数 自定义上传结束触发的事件，无论成功或者失败 error: () =&gt; &#123;&#125;, // 可选参数 上传失败触发的事件 success: () =&gt; &#123; &#125;, // 可选参数 上传成功触发的事件 change: (xhr, formData) =&gt; &#123; // xhr.setRequestHeader('myHeader','myValue') // formData.append('token', 'myToken') &#125; // 可选参数 每次选择图片触发，也可用来设置头部，但比headers多了一个参数，可设置formData &#125;, toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // 触发input框选择图片文件 if (value) &#123; document.querySelector('.avatar-uploader input').click() &#125; else &#123; this.quill.format('image', false); &#125; //QuillWatch.emit(this.quill.id) &#125; &#125; &#125;, ImageResize: &#123; //调整上传过后图片大小配置。 displayStyles: &#123; backgroundColor: 'black', border: 'none', color: 'white' &#125;, modules: [ 'Resize', 'DisplaySize','Toolbar' ] &#125;, &#125;, &#125; &#125; &#125;, methods: &#123; // * 上传失败的回调 handleImageErrorQuill() &#123; this.$message(&#123; message: "上传失败", type: "error" &#125;); &#125;, // * 文件超出个数限制时的钩子 beyondFileQuill(files, fileList) &#123; this.$message(&#123; message: "只能上传" + this.limit, type: "error" &#125;); &#125;, // * 上传成功 handleImageSuccessQuill(response, file, fileList) &#123; if (response) &#123; this.imageUrl = ossURL + response.name; // 向富文本插入图片链接 let quill = this.$refs.myQuillEditor.quill; let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 // 获取光标 设置属性 图片链接 quill.insertEmbed(length, `image`, `$&#123;ossURL + response.name&#125;`); quill.setSelection(length + 1); // 调整光标到最后 &#125; &#125;, // * 自定义上传覆盖默认上传 async fnUploadRequestQuill(option) &#123; oss.ossUploadFile(option,'image/'); &#125;, // * 上传前对图片进行验证 beforeAvatarUploadQuill(file) &#123; const isJPG = file.type === "image/jpeg" || file.type === "image/png" || file.type === "image/gif"; const isLtM = file.size / 1024 / 1024 &lt; 20; if (!isJPG) &#123; this.$message.error("上传头像图片只能是 JPG，PNG，GIF 格式!"); &#125; if (!isLtM) &#123; this.$message.error("上传头像图片大小不能超过 20MB!"); &#125; return isJPG &amp;&amp; isLtM; &#125; &#125;, watch: &#123; // 页面 value(newVAlue)&#123; this.context = newVAlue; &#125;, context(newValue)&#123; console.log(newValue); &#125; &#125;, filters: &#123;&#125;, computed: &#123;&#125;, components: &#123; quillEditor, quillRedefine, Quill &#125;&#125;&lt;/script&gt; 分析错误原因 123456789101112handleImageSuccessQuill(response, file, fileList) &#123; if (response) &#123; this.imageUrl = ossURL + response.name; // 向富文本插入图片链接 let quill = this.$refs.myQuillEditor.quill; let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 // 获取光标 设置属性 图片链接 quill.insertEmbed(length, `image`, `$&#123;ossURL + response.name&#125;`); quill.setSelection(length + 1); // 调整光标到最后 &#125;&#125;, 可以可看到报错信息 index of ‘null’ index 是我们通过quill.getSelection()获取到的 那也就是 quill.getSelection()里面没有index属性 我们将this.$refs.myQuillEditor.quill 打印出来看下在选择第一 个上传组件并上传 没有任何问题当选择第二个 上传组件并上传 找不到是null？？？ 这是什么鬼？？？ 解析：获取到的富文本实例 quill 获取不到光标的位置。 如何解决 且要保证已经完成代码不会出现问题 也不用去修改原来的代码，降低返工率 我们添加一个新的自定义属性props 用于获取$refs 123456789props: &#123; value:&#123; type:String, &#125;, quillEditorName:&#123; type:String, default:'myQuillEditor',// 没有传值 默认就是myQuillEditor 有就是传过来的值 &#125;&#125;, 我们将页面部分修改下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;template&gt; &lt;div class="quill-wrap"&gt; &lt;quill-editor v-model="content" :ref="quillEditorName" :options="editorOption" &gt;&lt;/quill-editor&gt; &lt;el-upload class="avatar-uploader" action ref="upload" name="img" :show-file-list="false" :auto-upload="true" :on-error="handleImageErrorQuill" :on-exceed="beyondFileQuill" :on-success="handleImageSuccessQuill" :http-request="fnUploadRequestQuill" :before-upload="beforeAvatarUploadQuill" :limit="limit" multiple &gt; &lt;i class="el-icon-plus avatar-uploader-icon" :id="quillEditorName+'Img'"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/template&gt; toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; image: (value)=&gt; &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 if (value) &#123; // 触发input框选择图片文件 document.querySelector('#' + this.quillEditorName + 'Img').click(); &#125; else &#123; this.quill.format("image", false); &#125; &#125; &#125;&#125; handleImageSuccessQuill(response, file, fileList) &#123; // 上传成功 if (response) &#123; this.imageUrl = ossURL + response.name; // 向富文本插入图片链接 let quill = this.$refs[this.quillEditorName].quill; let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 // 获取光标 设置属性 图片链接 quill.insertEmbed(length, `image`, `$&#123;ossURL + response.name&#125;`); quill.setSelection(length + 1); // 调整光标到最后 &#125;&#125;, 修改好了 我们在试下 最后贴上全部的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175&lt;template&gt; &lt;div&gt; &lt;quill-editor v-model="context" :ref="quillEditorName" :options="editorOption" @input="$emit('update:value', $event)" &gt; &lt;/quill-editor&gt; &lt;div class="upload" style='display:none'&gt; &lt;el-upload class="avatar-uploader" action ref="upload" name="img" :show-file-list="false" :auto-upload="true" :on-error="handleImageErrorQuill" :on-exceed="beyondFileQuill" :on-success="handleImageSuccessQuill" :http-request="fnUploadRequestQuill" :before-upload="beforeAvatarUploadQuill" :limit="limit" multiple &gt; &lt;i class="el-icon-plus avatar-uploader-icon" :id="quillEditorName+'Img'"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const ossURL = 'http://你自己的.com/'import &#123;quillEditor, Quill&#125; from 'vue-quill-editor';import &#123;container, ImageExtend, QuillWatch,&#125; from 'quill-image-extend-module';import &#123;quillRedefine&#125; from 'vue-quill-editor-upload';import ImageResize from 'quill-image-resize-module';Quill.register('modules/ImageResize', ImageResize )Quill.register('modules/ImageExtend', ImageExtend);import oss from "@/config/oss";export default &#123; mounted () &#123; this.context = this.value; &#125;, props:&#123; value:&#123; type:String, &#125;, quillEditorName:&#123; type:String, default:'myQuillEditor',// 没有传值 默认就是myQuillEditor 有就是传过来的值 &#125; &#125;, data() &#123; return &#123; limit:3, context:'', // 富文本框参数设置 editorOption: &#123; modules: &#123; ImageExtend: &#123; // 如果不作设置，即&#123;&#125; 则依然开启复制粘贴功能且以base64插入 name: '', // 图片参数名 size: 5, // 可选参数 图片大小，单位为M，1M = 1024kb action:"", // 服务器地址, 如果action为空，则采用base64插入图片 // response 为一个函数用来获取服务器返回的具体图片地址 // 例如服务器返回&#123;code: 200; data:&#123; url: 'baidu.com'&#125;&#125; 则 return res.data.url response: (res) =&gt; &#123;// 图片上传成功或错误 回调方法 成功后将图片地址return出去 return res.filePath; &#125;, headers: (xhr) =&gt; &#123; // 可选参数 设置请求头部 // xhr.setRequestHeader('Content-Type','multipart/form-data') &#125;, sizeError: () =&gt; &#123;&#125;, // 图片超过大小的回调 start: () =&gt; &#123;&#125;, // 可选参数 自定义开始上传触发事件 end: () =&gt; &#123;&#125;, // 可选参数 自定义上传结束触发的事件，无论成功或者失败 error: () =&gt; &#123;&#125;, // 可选参数 上传失败触发的事件 success: () =&gt; &#123; &#125;, // 可选参数 上传成功触发的事件 change: (xhr, formData) =&gt; &#123; // xhr.setRequestHeader('myHeader','myValue') // formData.append('token', 'myToken') &#125; // 可选参数 每次选择图片触发，也可用来设置头部，但比headers多了一个参数，可设置formData &#125;, toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // 触发input框选择图片文件 if (value) &#123; document.querySelector('#' + this.quillEditorName + 'Img').click(); &#125; else &#123; this.quill.format('image', false); &#125; &#125;.bind(this) // 或者你可以使用箭头函数 //'image': (value) =&gt; &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // // 触发input框选择图片文件 // if (value) &#123; // document.querySelector('#' + this.quillEditorName + 'Img').click(); // &#125; else &#123; /// this.quill.format('image', false); // &#125; //&#125; &#125; &#125;, ImageResize: &#123; //调整上传过后图片大小配置。 displayStyles: &#123; backgroundColor: 'black', border: 'none', color: 'white' &#125;, modules: [ 'Resize', 'DisplaySize','Toolbar' ] &#125;, &#125;, &#125; &#125; &#125;, methods: &#123; // * 上传失败的回调 handleImageErrorQuill() &#123; this.$message(&#123; message: "上传失败", type: "error" &#125;); &#125;, // * 文件超出个数限制时的钩子 beyondFileQuill(files, fileList) &#123; this.$message(&#123; message: "只能上传" + this.limit, type: "error" &#125;); &#125;, // * 上传成功 handleImageSuccessQuill(response, file, fileList) &#123; if (response) &#123; this.imageUrl = ossURL + response.name; // 向富文本插入图片链接 let quill = this.$refs[this.quillEditorName].quill; let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 // 获取光标 设置属性 图片链接 quill.insertEmbed(length, `image`, `$&#123;ossURL + response.name&#125;`); quill.setSelection(length + 1); // 调整光标到最后 &#125; &#125;, // * 自定义上传覆盖默认上传 async fnUploadRequestQuill(option) &#123; oss.ossUploadFile(option,'image/'); &#125;, // * 上传前对图片进行验证 beforeAvatarUploadQuill(file) &#123; const isJPG = file.type === "image/jpeg" || file.type === "image/png" || file.type === "image/gif"; const isLtM = file.size / 1024 / 1024 &lt; 20; if (!isJPG) &#123; this.$message.error("上传头像图片只能是 JPG，PNG，GIF 格式!"); &#125; if (!isLtM) &#123; this.$message.error("上传头像图片大小不能超过 20MB!"); &#125; return isJPG &amp;&amp; isLtM; &#125; &#125;, watch: &#123; // 页面 value(newVAlue)&#123; this.context = newVAlue; &#125;, context(newValue)&#123; console.log(newValue); &#125; &#125;, filters: &#123;&#125;, computed: &#123;&#125;, components: &#123; quillEditor, quillRedefine, Quill &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>富文本</tag>
        <tag>Quill</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Vuex的使用]]></title>
    <url>%2Fkms-123%2FVue-Vuex%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[记录在Vue中如何使用Vuex。 一. 什么是Vuex — 这里采用官方说明 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 总结: 多页面共享一个数据，不用每个页面重复请求一样的数据，单向数据流。 二. 如何安装？ 先创建Vue的项目 1vue init webpack my-vue-demo 安装Vuex插件 1npm install vuex --save 创建存储文件及目录 各个文件的作用 state state是什么？ 官方的解释是 state是唯一的数据源，每个Store只会存在一个 ； 用声明存储数据的地方。 state如何使用？和对象的写法一样 左边是key 右边是value；123456const state = &#123; // 什么一个值 一会我们会使用它 // 这里的值不能与modlue中文件名一致 userName:'',&#125;export default state mutation mutation是什么？ 官方的解释：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 用户修改state中声明的属性的值，且只能通过mutation事件才可以修改state中的值 mutation如何声明一个方法并修改state中的值 1234567const mutations = &#123; // 修改用户的名字 SET_USER(&#123; state &#125;, params) &#123; state.userName = params; &#125;&#125;export default mutations 如何使用(这里只简单的说下用法，进阶用法放在后面) 123456789101112131415161718192021222324252627282930313233在.vue文件中&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;h2 &gt;我的名字&#123;&#123;userName&#125;&#125;&lt;/h2&gt; &lt;button @click="handleSetUserName"&gt; 修改姓名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: "HelloWorld", data() &#123; return &#123; msg: "Welcome to Your Vue.js App", &#125;; &#125;, methods:&#123; // *修改state中userName的值 handleSetUserName()&#123; this.$store.commit('SET_USER','小红'); &#125; &#125;, // * 通过计算属性获取state中的值 但是一般我们是不会直接通过state获取值的 使用getter更好 computed:&#123; userName()&#123; return this.$store.state.userName; &#125;, &#125; &#125;; &lt;/script&gt; getter 什么是getter？ 官方解释：有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 通过getter你可以将state的数据过滤一次，返回你想要的数据格式或数据，并且它和计算属性一样，getter出去的属性，若与state中的属性一致，他会自动更新； 如何使用, 声明 1234const getters = &#123; userName: state =&gt; state.userName&#125;export default getters 使用 123456// 在.vue文件中computed:&#123; userName()&#123; return this.$store.getters.userName; &#125;,&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 我们修改下刚刚的案列 通过getter返回出去 &lt;template&gt; &lt;div class="hello"&gt; &lt;h2 &gt;我的名字&#123;&#123;userName&#125;&#125;&lt;/h2&gt; &lt;button @click="handleSetUserName"&gt; 修改姓名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; handleSetUserName()&#123; this.$store.commit('SET_USER','小红'); &#125; &#125;, computed:&#123; userName()&#123; return this.$store.getters.userName; &#125;, &#125; &#125;; &lt;/script&gt; ``` 4. action 1. 什么是action？ 1. 官方解释：Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 2. Action可以包含异步操作，在action中只能通过commit 修改state中的值 2. 如何使用 1. 如何声明 ```javascript import axios from 'axios'; const actions = &#123; 第一种 /* * state: 数据声明的state *commit 修改state 中属性值的方法 action只能通过mutation修改state中的属性 * params 是代用action方法传递过来的额外参数 可以不传 */ getUserInfo(&#123; state, commit &#125;, params) &#123; return axios.get('http://jsonplaceholder.typicode.com/users') &#125;, 第二种 // 或者你可以这样() getUserInfo(&#123; state, commit &#125;, params) &#123; axios.get('http://jsonplaceholder.typicode.com/users') .then(res =&gt; &#123; console.log(res); commit('SET_USER_LIST',res.data)// 这个时候我们就有了userList 数组了 // 等同于 // store.commit('SET_USER_LIST',res.data) &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); &#125;, &#125; export default actions 如何使用 123456789101112131415第一种 直接获取 mounted()&#123; let a = this.$store.dispatch('getUserInfo') a.then(res =&gt; &#123; console.log(res); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); console.log(a); &#125;,第二种 直接存储在vuex state中mounted()&#123; this.$store.dispatch('getUserInfo') &#125;, Module(模块) 什么是模块？ 官方解释：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 当做一个大型的项目时，或项目更加复杂时 vuex回变得非常的庞大臃肿，不利于数据的维护，我们可以将它切割成多个模块(文件)，每个模块又包含state getters actions mutation 如何使用 如何声明 12345678910111213141516171819202122232425262728293031323334353637383940我们将刚刚写的demo都放在模块中// store/module/user.js import axios from 'axios'; const state = &#123; userName: '小明', userList:[], &#125; const mutations = &#123; // 修改用户的名字 SET_USER:( state , params)=&gt; &#123; state.userName = params; &#125;, SET_USER_LIST:( state , params)=&gt; &#123; state.userList = params; &#125; &#125; const actions = &#123; /* * state: 数据声明的state *commit 修改state 中属性值的方法 action只能通过mutation修改state中的属性 * params 是代用action方法传递过来的额外参数 可以不传 */ getUserInfo(&#123; state, commit &#125;, params) &#123; axios.get('http://jsonplaceholder.typicode.com/users') .then(res =&gt; &#123; commit('SET_USER_LIST',res.data)// 这个时候我们就有了userList 数组了 &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); &#125;, &#125; const getters = &#123; userName: state =&gt; state.userName &#125; export default &#123; namespaced:true,// 是否开启命名空间 默认是不开启的 开启命名空间调用时在原本的方法前面添加模块 state, mutations, actions, getters &#125; //注别忘记在store中引用它 // store/index.js import user from './module/user.js' 如何使用在原本的方法前面添加模块名 也就是user 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2 &gt;我的名字&#123;&#123;userName&#125;&#125;&lt;/h2&gt; &lt;button @click="handleSetUserName"&gt; 修改姓名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "HelloWorld", mounted()&#123; this.$store.dispatch('user/getUserInfo') &#125;, data() &#123; return &#123; msg: "Welcome to Your Vue.js App", &#125;; &#125;, methods:&#123; handleSetUserName()&#123; this.$store.commit('user/SET_USER','小红'); &#125; &#125;, computed:&#123; userName()&#123; return this.$store.getters['user/userName']; &#125;, &#125;&#125;;&lt;/script&gt; 进阶使用map辅助函数 第一种 (推荐，自己习惯这种对象的方式) 1234567891011121314151617181920212223242526272829303132333435363738// 推荐写法 &lt;script&gt; // 在这里声明 import &#123; mapState, mapGetters, mapActions, mapMutations &#125; from 'vuex' export default &#123; name: "HelloWorld", mounted()&#123; this.getUserInfo(); &#125;, data() &#123; return &#123; msg: "Welcome to Your Vue.js App", &#125;; &#125;, methods:&#123; handleSetUserName()&#123; this.SET_USER('小红'); &#125;, ...mapMutations(&#123; // 添加了user 就是获取模块中的 SET_USER:'user/SET_USER' // 获取公共的 //SET_USER:'SET_USER' &#125;), ...mapActions(&#123; getUserInfo:'user/getUserInfo' &#125;) &#125;, computed:&#123; ...mapState(&#123; userName: state =&gt; state.user.userName, &#125;), ...mapGetters(&#123; userList: 'user/userList' &#125;) &#125; &#125;; &lt;/script&gt; 第二种 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2 &gt;我的名字&#123;&#123;userName&#125;&#125;&lt;/h2&gt; &lt;button @click="handleSetUserName"&gt; 修改姓名&lt;/button&gt; &#123;&#123;userList&#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; mapState, mapGetters, mapActions, mapMutations &#125; from 'vuex' export default &#123; name: "HelloWorld", mounted()&#123; this.getUserInfo(); &#125;, data() &#123; return &#123; msg: "Welcome to Your Vue.js App", &#125;; &#125;, methods:&#123; handleSetUserName()&#123; this.SET_USER('小红'); &#125;, ...mapMutations('user',['SET_USER']), ...mapActions('user',['getUserInfo']) &#125;, computed:&#123; ...mapState('user',['userName']), ...mapGetters('user',['userList']) &#125; &#125;; &lt;/script&gt; 不止有第三种还有第四种第五种 这里就不一一列举了 掌握常用的就已经足够了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现一个气泡框]]></title>
    <url>%2Fkms-123%2FCSS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B0%94%E6%B3%A1%E6%A1%86.html</url>
    <content type="text"><![CDATA[一. 需求: CSS代码实现一个带三角型的气泡框 二. 如何实现 创建页面结构 123456&lt;div class="app"&gt; &lt;div class="wrap" &gt; 好好学习天天向上 &lt;/div&gt; &lt;button class="button"&gt;点击&lt;/button&gt;&lt;/div&gt; Javascript 123456789101112// 将显示的元素通过js放在 按钮的位置window.onload= ()=&gt;&#123; let $ = function (className)&#123; return document.querySelector(className); &#125; $('.button').click = ()=&gt;&#123; document.body.appendChild($('.wrap')); let &#123;width,height,left, top&#125; = $('.button').getBoundingClientRect(); let &#123;height:height2&#125; = $('.wrap').getBoundingClientRect(); // -height-12为 按钮的高度 加箭头的高度 和 边框厚度 $('.wrap').style.top = top+window.scrollY - height-12+ 'px'; $('.wrap').style.left = left+window.scrollX + 'px'; &#125;&#125; 3.CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 按钮样式 .button&#123; font-size: 14px; height: 32px; padding: 0 1em; border-radius: 4px; border: 1px solid #999; background-color: #eee; display: inline-flex; justify-content: center; align-items: center; vertical-align: middle;&#125;.app&#123; display: inline-block; vertical-align: top; position: relative;&#125;.wrap&#123; position: absolute; border: 1px solid #333; border-radius:4px; padding: .5em 1em; // box-shadow: 0 1px 1px rgba(0, 0, 0, .5); filter: drop-shadow(0 1px 1px rgba(0, 0, 0, .5)); background-color: white; max-width: 20em; word-break: break-all; &amp;::before,&amp;::after&#123; content: ''; display: block; border: 10px solid transparent; width: 0; height: 0; position:absolute; transform: translateY(-100%); margin-top: 20px; &#125; &amp;::before,&amp;::after&#123; left: 10px; &#125; &amp;::before&#123; border-top-color: black; top: 100%; &#125; &amp;::after&#123; border-top-color: white; top: calc(100% - 1px); &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>三角形</tag>
        <tag>气泡框</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue中使用axios + 封装一次axios]]></title>
    <url>%2Fkms-123%2F%E5%B0%81%E8%A3%85axios.html</url>
    <content type="text"><![CDATA[一. 什么是axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 官方文档 二. 如何安装到项目中1npm install axios 三. 如何在项目中使用 如何发送GET请求 123456789axios.get('http://jsonplaceholder.typicode.com/posts',&#123; params:&#123; id:1 &#125; // ?拼接的方式传参&#125;).then((res)=&gt;&#123; // 请求成后的回调 console.log(res);&#125;).catch((error)=&gt;&#123;// 任何错误的出口 console.log(error);&#125;) 如何发送POST请求 123456789axios.post('https://jsonplaceholder.typicode.com/posts',&#123; id:1 // // post传参&#125;).then((res)=&gt;&#123; // 请求成后的回调 console.log(res);&#125;).catch((error)=&gt;&#123;// 任何错误的出口 console.log(error);&#125;) 使用对象的方式 1234567891011axios(&#123; method: 'post', // 请求方式 url: '/user/12345', // 请求地址 data: &#123; // 请求参数 firstName: 'Fred', lastName: 'Flintstone' &#125;, headers:&#123;&#125;, // 设置自定义请求头 timeout:5, // 请求中断时间 超过5秒 自动请求失败 ···// 更多查看官方文档&#125;); 无论是哪一种方式传参返回 回来的都是响应的主体。它们中我们仅需要的就是data 如何让返回结果只包含data，请求携带token呢？ 四. axios拦截器的使用 什么是拦截器: 请求拦截器在请求发送之前我们需要做的一些事，它们需要我们反复的添加并且一样。比如添加token验证，参数序列化，修改请求头，等操作 响应拦截器在响应回来我们需要做的一些事，它们需要我们反复的添加，修改并且一样。比如简化请求返回体，一致的状态码返回处理，等 全局请求拦截器 123456789101112axios.interceptors.request.use( (config) =&gt; &#123;// 在发送请求之前做些什么 // 我们可以在这里添加网站的token验证 // if (getToken()) &#123; // 判断是否存在token，如果存在的话，则每个http header都加上token // config.headers.Authorization = `$&#123;getToken()&#125;`; // &#125; return config; &#125;, (error) =&gt; &#123;// 对请求错误做些什么 return Promise.reject(error); &#125;); 全局响应拦截器 12345678910111213axios.interceptors.response.use( (response) =&gt; &#123; // 对响应数据做点什么 // 在这里我们可以将请求体简化 let data = response.data; if(data.status === 4009)&#123; // console.log('登录失效了') // location.href = 'login.html'// 直接跳转登录页 &#125; return data; // 最后将数据返回出去 &#125;, (error) =&gt; &#123;// 对响应错误做点什么 return Promise.reject(error); &#125;); 了解完以上内容我们就可以自己封装一个axios请求的方法了，不过我们可以在了解下其他的，这样会更加的有利于我们封装 五. 全局参数设置 全局默认请求地址前缀。 axios.defaults.baseURL = ‘https://api.example.com&#39;; 全局默认请求token axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; 全局post默认请求头 axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 全局参数默认序列化(坑) 不过我们不用这个。我们有更好的东西1234567axios.defaults.transformRequest = [function (data) &#123; let ret = &apos;&apos; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos; &#125; return ret &#125;], 六. 在Vue中封装一个axios通过上面的只是储备，我们闲话不多说，开始封装 安装axios npm i axios npm i qs // 使用qs 代替axios中的参数序列化方法 在发送post请求,不将参数序列化，当你请求的时候会一直报错(400，传参错误)。原因就是你参数后台识别不了 在src目录下创建 api文件夹 在api文件夹下创建ajax.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/api/ajax.jsimport axios from 'axios'import qs from 'qs' // 设置全局axios 配置axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';axios.defaults.baseURL = 'http://wwww.xxx.com';// 请求都是 http://wwww.xxx.com 开头 + url// 设置请求拦截器axios.interceptors.request.use( (config) =&gt; &#123;// 在发送请求之前做些什么 // if (getToken()) &#123; config.headers.Authorization = `$&#123;getToken()&#125;`; &#125; return config; &#125;, (error) =&gt; &#123;// 对请求错误做些什么 return Promise.reject(error);&#125;);axios.interceptors.response.use( (response) =&gt; &#123; // 对响应数据做点什么 let data = response.data; if(data.status === 4009)&#123; // console.log('登录失效了') &#125; return data; // 最后将数据返回出去 &#125;, (error) =&gt; &#123;// 对响应错误做点什么 return Promise.reject(error);&#125;);//重新定义post请求export const post = (url, params) =&gt; &#123; return axios(&#123; method: 'post', url: `$&#123;url&#125;`, data: qs.stringify(params), &#125;);&#125;;//重新定义get请求export const get = (url,params) =&gt; &#123; return axios(&#123; method: 'get', url: `$&#123;url&#125;`, params &#125;);&#125;; 如何全局使用在main.js 将其挂载到Vue上 123import &#123; post, get &#125; from &apos;./api/ajax&apos;Vue.prototype.$post = postVue.prototype.$get = get 模块化请求url在api目录下 新增项目对应的模块js文件(便于维护) 123// src/api/urlexport const login = '/front/customer/login' // 用户登录 ?phone=''&amp;password=''export const shopping = '/front/goods/goodsGroup' // 获取商品 如何使用我们将方法挂载到Vue上后就可以使用this.$post/this.$get 来获取了 1234567891011121314151617181920212223242526272829303132&lt;!-- 页面 --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;我是axios测试页面&lt;/p&gt; &lt;button @click="handleLogin"&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;shopping&#125; from '@/api/url'export default &#123;mounted () &#123; this.$post(shopping) .then(res =&gt; &#123; console.log(res) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;)&#125;,methods: &#123; handleLogin () &#123; this.$post(login, &#123;phone: 15555555555, password: 123456&#125;) .then(res =&gt; &#123; console.log(res) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125;&#125;&lt;/script&gt; 七. 恭喜你Get到一个新技能]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标滚动事件的总结]]></title>
    <url>%2Fkms-123%2F%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[一. 什么是鼠标滚轮事件？ 鼠标滚轮事件: 用户通过鼠标滚动触发的事件。 二. 如何使用？鼠标滚动事件一直存在着兼容性问题，主要区分为是火狐浏览器，非火狐浏览器 在非火狐浏览器下如何使用(IE,360,Chrome)。12345let wheel = function ()&#123; console.log('Hello world')&#125;;window.onmousewheel = document.onmousewheel = wheel; 问题: 这样写在单页面应用中离开当前页还是存在事件 只能通过强行赋值的方式清除 window.onmousewheel = document.onmousewheel = wheel=function(){}如何解决:12window.addEventListener('mousewheel', wheel, false);window.removeEventListener('mousewheel', wheel, false); 这样鼠标每次滚动都会输出一次，不论是向上还是向下;离开单页面也会清楚事件 在火狐浏览器下如何使用 123456let wheel = function ()&#123; console.log('Hello world')&#125;;if (window.addEventListener) &#123; window.addEventListener('DOMMouseScroll', wheel, false);&#125; 火狐浏 览器没有 ‘onmousewheel’ 事件 所以使用火狐浏览器自带的 ‘DOMMouseScroll’ 事件 可以共用的方法通过上面的总结我们可以做一个公用的方法 在浏览器中使用 1234567let wheel = function ()&#123; console.log('Hello world')&#125;;if (window.addEventListener) &#123; window.addEventListener('DOMMouseScroll', wheel, false);&#125; window.addEventListener('mousewheel', wheel, false); 三. 上下滚动事件？ 有时候单独的滚动事件并不能满足我们的需求，我们需要更加复杂的变化。向上滚动/向下滚动 它们也存在着浏览器兼容性的问题 非火狐浏览器/火狐浏览器 非火狐浏览器 123456789101112131415var wheel = function (event)&#123; var delta = 0; if (!event)&#123; event = window.event; /* For IE. */ &#125; // event.wheelDelta 向下滚动是-120 向上滚动是120 if (event.wheelDelta) &#123; /* IE/Opera. Chrome*/ delta = event.wheelDelta / 120; &#125; if (event.preventDefault)&#123;// 去除浏览器默认事件 event.preventDefault(); &#125; event.returnValue = false;&#125;;document.addEventListener('mousewheel',wheel,false) 火狐浏览器 火狐浏览器没有wheelDelta 属性 可以使用detail 代替 12345678910111213141516var wheel = function (event)&#123; var delta = 0; if (!event)&#123; event = window.event; /* For IE. */ &#125; // event.detail 向下滚动是3 向上滚动是-3(3的倍数) 与其他浏览器不一致 所以在值的前面加个"-" 这样向上滚动是 正值 向下滚动是负值 if (event.detail) &#123; delta = -event.detail / 3; &#125; if (event.preventDefault)&#123;// 去除浏览器默认事件 event.preventDefault(); &#125; event.returnValue = false;&#125;;window.addEventListener('DOMMouseScroll', wheel, false); 可以共用的方法(滚动事件 + 上下滚动事件)通过上面的总结我们可以做一个公用的方法 在浏览器中使用 123456789101112131415161718192021222324var wheel = function(event) &#123;// 解决浏览器兼容性 滑轮滚动问题 var delta = 0; if (!event) /* For IE. */ event = window.event; if (event.wheelDelta) &#123; /* IE/Opera.Chrome*/ delta = event.wheelDelta / 120; &#125; else if (event.detail) &#123;/*火狐*/ delta = -event.detail / 3; &#125; if (delta)&#123; if(delta&gt;0)&#123; console.log('我在向上滚'); &#125;else if(delta&lt;0)&#123; console.log('我在向下滚'); &#125; &#125; if (event.preventDefault) event.preventDefault(); event.returnValue = false;&#125;if (window.addEventListener) &#123; window.addEventListener('DOMMouseScroll', wheel, false);&#125;document.addEventListener('mousewheel',wheel,false)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>鼠标</tag>
        <tag>滚轮</tag>
        <tag>屏幕高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于video标签的总结]]></title>
    <url>%2Fkms-123%2F%E5%85%B3%E4%BA%8Evideo%E6%A0%87%E7%AD%BE%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[一. video标签的基本属性及基本事件。 基本属性 123456789autoplay: false 是否自动播放controls: false 是否显示播放控件loop: false 是否是循环播放muted: false 是否是静音播放poster:&quot;&quot; 在播放第一帧之前显示的海报preload: 视频预加载策略 auto: 预加载视频元数据和缓冲一定时长 metadata: 只加载 元数据(第一帧画;时长) none: 不加载任何数据 基本事件 123456789101112duration: 总时长paused:true 当前视频是否处于暂停状态 true是暂停 false是播放volume:1 当前音量playbackRate: 回放速率 大于1快放 不于1慢放成员方法===play() 播放视频pause() 暂停视频成员事件==onplay 当视频开始播放时触发的事件onpause 当视频暂停播放时触发的事件 二. 在移动端设备 video 标签的使用及踩坑123456789&lt;video src=&quot;&quot; id=&quot;myVideo&quot; x5-playsinline=&quot;&quot; poster=&quot;&quot; x-webkit-airplay=&quot;allow&quot; preload=&quot;auto&quot; autoplay x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot; x5-video-ignore-metadata=&apos;true&apos; controls webkit-playsinline=&quot;true&quot; playsinline width=&apos;100%&apos; height=&apos;100%&apos;&gt; &lt;/video&gt; 如何让视屏与页面在同一层级 标签上需要添加 123x5-video-player-type="h5" 5-video-player-fullscreen="true" &lt;!-- 让播放的视频与页面同层显示 不然视频会悬浮 --&gt; 如何禁止video在ios系统中自动全屏播放 1x5-playsinline webkit-playsinline="true" playsinline 三. 在PC端 video 的使用及踩坑 如何禁止用户下载视屏 从HTML=&gt; 添加禁止下载属性 controlslist=”nodownload” 但任然有浏览器可以下载 从|CSS=&gt; 123456789video::-internal-media-controls-download-button &#123; display:none;&#125;video::-webkit-media-controls-enclosure &#123; overflow:hidden;&#125;video::-webkit-media-controls-panel &#123; width: calc(100% + 30px); &#125; 从JS=&gt; 针对uc自定义悬浮下载按钮解决办法 uc浏览器会给每个video添加 uc-video-toolbar-id 扩展属性 之要将这个属性去除就可以了 $(‘#my-video’).attr(‘uc-video-toolbar-id’,’’) document.getElementById(‘my-video’).setAttribute(‘uc-video-toolbar-id’,’’) document.getElementById(‘my-video’).removeAttribute(‘uc-video-toolbar-id’)// 直接删除添加的属性]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>video</tag>
        <tag>视屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用vue-video-player(Nuxt.js版)]]></title>
    <url>%2Fkms-123%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8vue-video-player.html</url>
    <content type="text"><![CDATA[一. 安装需要的模块1npm install vue-video-player --save 二. 如何引入插件 在plugins文件夹中添加video.js。内容如下123456import Vue from './node_modules/vue'import VideoPlayer from './node_modules/vue-video-player'import './node_modules/video.js/dist/video-js.css'import './node_modules/vue-video-player/src/custom-theme.css'// import './node_modules/videojs-contrib-hls';// hls 可自行添加Vue.use(VideoPlayer) 三. 如何使用 在Nuxt.js框架配置文件中 nuxt.config.js 添加我们刚刚创建好的video.js文件 ssr设为false (不启用服务器端渲染) 1234567plugins: [ &#123; src: '~plugins/element-ui', ssr: true &#125;, &#123; src: '~plugins/svj', ssr: false &#125;, &#123; src: '~plugins/main', ssr: true &#125;, &#123; src: '~plugins/video', ssr: false &#125;,], 在page中新增video.vue页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;video-player class="video-player vjs-custom-skin" ref="videoPlayer" :playsinline="true" :options="playerOptions" @play="onPlayerPlay($event)" @pause="onPlayerPause($event)" &gt;&lt;/video-player&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; playerOptions: &#123; playbackRates: [0.7, 1.0, 1.5, 2.0], //播放速度 autoplay: false, //如果true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 导致视频一结束就重新开始。 preload: 'auto', // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: 'zh-CN', aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如"16:9"或"4:3"） fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [ &#123; type: 'video/mp4', src:'http://oss-xzb.oss-cn-beijing.aliyuncs.com/Files/61749a95c3c1b700b4842d8585ff0812.mp4' &#125; ], poster: 'https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=40606c56972bd40746c7d4ff4b889e9c/377adab44aed2e73c29074528701a18b87d6fa57.jpg', //你的封面地址 width: '100%', notSupportedMessage: '此视频暂无法播放，请稍后再试', //允许覆盖Video.js无法播放媒体源时显示的默认信息。 &#125; &#125; &#125;, methods: &#123; onPlayerPlay(player) &#123;&#125;, onPlayerPause(player) &#123;&#125; &#125;, computed: &#123; player() &#123; return this.$refs.videoPlayer.player &#125; &#125;&#125;&lt;/script&gt;&lt;style type="text/css" scoped&gt;.container &#123; background-color: #efefef; min-height: 100%;&#125;&lt;/style&gt; 四. 踩坑和注意事项 playerOptions.sources 的值是对象格式 我使用的类型是 type/mp4 不要直接照着网上12&#123;type: "application/x-mpegURL", src: "video.m3u8" &#125; 人家这个是m3u8格式的 你的是什么格式就填写什么格式的；不然打开就是错的提示12此视频暂无法播放，请稍后再试 这个也是配置中的展示信息notSupportedMessage: &apos;此视频暂无法播放，请稍后再试&apos;, //允许覆盖Video.js无法播放媒体源时显示的默认信息。 封面图采用网络地址 我使用相对路径和绝对路径发现并没有什么用 还爆出404找不到文件路径 1poster: &apos;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=40606c56972bd40746c7d4ff4b889e9c/377adab44aed2e73c29074528701a18b87d6fa57.jpg&apos; 如何获取当前的video的对象？ 1234&lt;!-- 当前视频对象 --&gt;this.$refs.videoPlayer.player1. 可以根据对象 获取当前视频播放时长：console.log(this.$refs.videoPlayer.player.currentTime(),&apos;当前时间&apos;);2. 可以根据对象 获取当前视频总时长console.log(this.$refs.videoPlayer.player.duration,&quot;总时长&quot;); 五. 参考阅读 官方文档是最总要的 传送门 参考博文 传送门 各种属性详解传送们]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vue-video-player</tag>
        <tag>video</tag>
        <tag>视屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果手机显示时间NaN]]></title>
    <url>%2Fkms-123%2F%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4NaN.html</url>
    <content type="text"><![CDATA[一. 出现的问题 写一个倒计时功能，使用普通的写法(获取时间的毫秒数) new Date(“2019-1-5”).getTime(); 在安卓设备可以正常显示。在苹果设备上显示NaN 什么是NaN 通常都是在计算失败时，作为 Math 的某个方法的返回值出现的（例如：Math.sqrt(-1)）或者尝试将一个字符串解析成数字但失败了的时候（例如：parseInt(“blabla”)）。 什么时候会返回NaN 在做计算时，无穷大除以无穷大、给任意负数做开方运算 或者 算数运算符与不是数字或无法转换为数字的操作数一起使用时都将返回 NaN。 二. 解决方案 使用 new Date(time.replace(/-/g,’/‘)).getTime()利用正则将格式转换成时间的标准格式，也就是将原有的时间日期格式转成(2019-1-5 ===&gt; 2019/1/5) 三. 问题的原因 new Date(time1)这个构造函数无法正确的生成Date对象，其值为Invalid Date. 2019/1/5 这是时间的标准格式 被各大浏览器广泛支持 而2019-1-5 只有chrome能够很好的支持]]></content>
      <categories>
        <category>移动设备浏览器兼容性</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>js</tag>
        <tag>浏览器兼容性</tag>
        <tag>苹果手机</tag>
        <tag>NaN</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果手机window.open无法打开连接]]></title>
    <url>%2Fkms-123%2F%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BAwindow.open%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%BF%9E%E6%8E%A5.html</url>
    <content type="text"><![CDATA[一. 出现的问题 在H5中，使用操作打开一个新的网页；使用 window.open(url)方法。在安卓手机中是可以实现功能跳转第三方网页，但在苹果手机上相同的方法缺无法运行,用户点击后页面无任何操作(在微信中，二者均可以运行，钉钉，uc不行，QQ浏览器安卓会有提示) 二. 解决方案使用 使用window.location.replace 代替 window.open 三. 问题的原因 苹果手机 Safari中无法open新窗口，原因是Safari的安全机制将其阻止，一些异步操作，比如ajax回调里面执行window.open就会失效，原因是代码自己自动执行的，被IOS的安全机制拦截！ 在点击事件中还是可以使用的 但不要将他放在异步事件中]]></content>
      <categories>
        <category>移动设备浏览器兼容性</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
        <tag>苹果</tag>
        <tag>安卓</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt用户登录路由鉴权]]></title>
    <url>%2Fkms-123%2FNuxt%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83.html</url>
    <content type="text"><![CDATA[在使用Nuxt.js框架中 无法像Vue中使用sessionStorage，LocalStorage将数据存储在本地。无法存储在本地就失去判断用户是否登录的条件，有什么办法能够判断用户是否登录了呢？ 一. 安装需要的依赖npm install js-cookie --save 二. 在登录页面 Login1234567891011121314151617181920212223242526272829 import Cookie from 'js-cookie' data() &#123; return &#123; redirectURL:'/' &#125; &#125;, mounted() &#123; // 初始化路由 let rediretUrl = this.$route.query.ref if (rediretUrl) &#123; this.redirectURL = rediretUrl &#125; &#125;, methods:&#123; // 登录的方法 handleLogin() &#123; post(login, &#123; phone: 15555429216, password: 123456 &#125;) .then(res =&gt; &#123; if (res.status === 200) &#123; Cookie.set('token',res.token) this.$router.push('/afterLogin') &#125; &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125;&#125;, 三. 添加权限中间件 与 需求文件 在middleware中新增auth.js文件 123456789101112131415161718192021222324252627import utils from '../utils/utils'export default function (&#123; route, req, res, redirect &#125;) &#123; let isClient = process.client; let isServer = process.server; let redirectURL = '/login'; var token, path // console.log(req); // console.log(isClient,isServer); //在服务端 if (isServer) &#123; let cookies = utils.getcookiesInServer(req) path = req.originalUrl; token = cookies.token || '' &#125; //在客户端判读是否需要登陆 if (isClient) &#123; token = utils.getcookiesInClient('token') path = route.path; &#125; if (path) &#123; redirectURL = '/login?ref=' + encodeURIComponent(path) &#125; //需要进行权限判断的页面开头 if (!token) &#123; redirect(redirectURL) &#125;&#125; utils方法 在根目录添加新增 utils/utils.js 1234567891011121314151617import Cookie from 'js-cookie'export default &#123; //获取服务端cookie getcookiesInServer:function (req) &#123; let service_cookie = &#123;&#125;; req &amp;&amp; req.headers.cookie &amp;&amp; req.headers.cookie.split(';').forEach(function (val) &#123; let parts = val.split('='); service_cookie[parts[0].trim()] = (parts[1] || '').trim(); &#125;); return service_cookie; &#125;, //获取客户端cookie getcookiesInClient: function (key) &#123; console.log(key); return Cookie.get(key) ? Cookie.get(key) : '' &#125;&#125; 四. 如何使用 在需要的权限的页面添加 1middleware: 'auth' 参考：https://blog.csdn.net/umufeng/article/details/80524766]]></content>
      <categories>
        <category>Nuxt</category>
      </categories>
      <tags>
        <tag>Nuxt</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt采坑锦集]]></title>
    <url>%2Fkms-123%2FNuxt%E9%87%87%E5%9D%91%E9%94%A6%E9%9B%86.html</url>
    <content type="text"><![CDATA[一. 在Nuxt中使用Element-UI报错 报错：直接安装官方NuxtCli脚手架 使用Element-UI 刷新页面报错 123The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside &lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing full client-side render.客户端呈现的虚拟DOM树与服务器呈现的内容不匹配。这可能是由于不正确的HTML标记造成的，例如将块级元素嵌套在&lt;p&gt;中，或者缺少&lt;tbody&gt;。对水化进行处理并执行完整的客户端呈现。 解决：找到项目目录下的 plugins/element-ui.js 将1 修改为2 重新启动服务 引入其他的组件 插件可能也会出现这种问题 可以尝试使用包裹元素]]></content>
      <categories>
        <category>Nuxt</category>
      </categories>
      <tags>
        <tag>Nuxt</tag>
        <tag>Vue</tag>
        <tag>Element-UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的Markdown语法]]></title>
    <url>%2Fkms-123%2F%E5%B8%B8%E7%94%A8%E7%9A%84Markdown%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[1.如何生成地址链接：1[地址链接](http://127.0.0.1:4000/categories/ &quot;地址链接&quot;) 地址链接 2.插入图片超链接的格式如下：1![图片说明](图片链接 &quot;图片标题&quot;) 3.使用 &gt; 表示文字引用： 野火烧不尽，春风吹又生 4.无序列表12345+ 列表一 - 子列表 * 子-子列表+ 列表二+ 列表三 列表一 子列表 子-子列表 列表二 列表三 jhjhj mkmm m,mm,是多少反倒是 lmklmk 个梵蒂冈 5.有序列表1231. 有序列表git 1. 子列表2. 有序列表 有序列表 子列表 有序列表 6.绘制表格1234567&lt;!-- &lt;tr&gt;&lt;/tr&gt; --&gt;| Item | Value | Qty |&lt;!-- 对其方式 左 中 右--&gt;| :------- | --------: | :---: || Computer | 1600 USD | 5 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 123&lt;script&gt; var a = 10&lt;/script&gt; 1var a =10 1npm install 使用技巧 换行： 方法1: 连续两个以上空格+回车 方法2：使用html语言换行标签： 首行缩进两个字符：(每个表示一个空格，连续使用两个即可） ‘&amp;ensp ;’ 半角的空格 ‘&amp;emsp ;’ 全角的空格 字体颜色 lalalala hexo 常用命令12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue中添加Quill富文本插件]]></title>
    <url>%2Fkms-123%2FVue%E4%B8%AD%E6%B7%BB%E5%8A%A0Quill%E5%AF%8C%E6%96%87%E6%9C%AC.html</url>
    <content type="text"><![CDATA[一. 安装Quill富文本和扩展包npm install vue-quill-editor quill-image-extend-module vue-quill-editor-upload quill-image-resize-module --save 富文本 图片**插件 图片上传插件 图片可调整大小插件 还有个图片拖拽上传插件，项目中没有这个需求，引入打包还会报错，占时没有添加 二. 添加配置 全局引入css样式 12345// main.js// 引入富文本样式import &apos;quill/dist/quill.core.css&apos;;import &apos;quill/dist/quill.snow.css&apos;;import &apos;quill/dist/quill.bubble.css&apos;; 在需要使用富文本页面添加引用依赖 1234567//**.vue页面(建议封装成组件，后面有封装过程)import &#123;quillEditor, Quill&#125; from 'vue-quill-editor';import &#123;container, ImageExtend, QuillWatch,&#125; from 'quill-image-extend-module';import &#123;quillRedefine&#125; from 'vue-quill-editor-upload';import ImageResize from 'quill-image-resize-module' // 调整图片大小组件。Quill.register('modules/ImageExtend', ImageExtend);Quill.register('modules/ImageResize', ImageResize ) 在组件中注册和添加富文本配置信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364data:&#123; return &#123; context:'', // 富文本框参数设置 editorOption: &#123; modules: &#123; ImageExtend: &#123; // 如果不作设置，即&#123;&#125; 则依然开启复制粘贴功能且以base64插入 name: 'fileFile', // 图片参数名 size: 5, // 可选参数 图片大小，单位为M，1M = 1024kb action:'', // 服务器地址, 如果action为空，则采用base64插入图片 // response 为一个函数用来获取服务器返回的具体图片地址 // 例如服务器返回&#123;code: 200; data:&#123; url: 'baidu.com'&#125;&#125; 则 return res.data.url response: (res) =&gt; &#123;// 图片上传成功或错误 回调方法 成功后将图片地址return出去 return res.filePath; &#125;, headers: (xhr) =&gt; &#123; // 可选参数 设置请求头部 // xhr.setRequestHeader('Content-Type','multipart/form-data') &#125;, sizeError: () =&gt; &#123;&#125;, // 图片超过大小的回调 start: () =&gt; &#123;&#125;, // 可选参数 自定义开始上传触发事件 end: () =&gt; &#123;&#125;, // 可选参数 自定义上传结束触发的事件，无论成功或者失败 error: () =&gt; &#123;&#125;, // 可选参数 上传失败触发的事件 success: () =&gt; &#123; &#125;, // 可选参数 上传成功触发的事件 change: (xhr, formData) =&gt; &#123; // xhr.setRequestHeader('myHeader','myValue') // formData.append('token', 'myToken') &#125; // 可选参数 每次选择图片触发，也可用来设置头部，但比headers多了一个参数，可设置formData &#125;, toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // if (value) &#123; // // 触发input框选择图片文件 // document.querySelector('.avatar-uploader input').click() // &#125; else &#123; // this.quill.format('image', false); // &#125; QuillWatch.emit(this.quill.id) &#125; &#125; &#125;, ImageResize: &#123; //调整上传过后图片大小配置。 displayStyles: &#123; backgroundColor: 'black', border: 'none', color: 'white' &#125;, modules: [ 'Resize', 'DisplaySize','Toolbar' ] &#125;, &#125;, &#125;, &#125;&#125;// 注册组件components: &#123; quillEditor &#125;// 在页面中使用&lt;template&gt; &lt;div&gt; &lt;quill-editor v-model="context" ref="myQuillEditor" :options="editorOption" &gt;&lt;/quill-editor&gt; &lt;/div&gt;&lt;/template&gt; 你认为成功了？NoNoNo！！！ 你会报出一个错误，就是下面这个，TypeError: Cannot read property ‘imports’ of undefined错误原因: 引用图片调整大小的插件引起的， Quill还没有在window上挂在 webpack编译已经结束了如何解决: 1234567891011121314151617//在webpack.base.conf.js文件下1. 添加：const webpack=require('webpack');2. module.exports = &#123; context: path.resolve(__dirname, '../'), entry：&#123;&#125;, output:&#123;&#125;, // 在这里添加 请不要放在output前面 那样会报错 plugins: [ new webpack.ProvidePlugin(&#123; 'window.Quill': 'quill/dist/quill.js', 'Quill': 'quill/dist/quill.js' &#125;), ], resolve:&#123;&#125;, ···&#125; 修改了配置文件我们重新启动下项目 npm run dev如果上传了图片四周出现了小’脚’那么说明你就成功了 试试放大，缩小它 三.封装成组件 还没有结束！这么多的配置，没个评论都要用这个富文，每个页面都复制粘贴这么庞大的代码岂不累死我。封装它，弄成组件。盘它 将刚刚完成的页面改个响亮的名字 ===&gt; quill.vue 12345678910111213141516171819202122232425262728// 给富文本标签添加input事件(每次输入都会调用下这个方法)&lt;template&gt; &lt;div&gt; &lt;quill-editor v-model="context" ref="myQuillEditor" :options="editorOption" @input="$emit('update:value', $event)" &gt; &lt;/quill-editor&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; // 添加props接受父组件传来的值， props:&#123; value:&#123; type:String, &#125;, &#125;, // watch 方法是为了父组件传给子组件新的值 子组件自动更新最新的值 watch: &#123; value(newVAlue)&#123; console.log(newVAlue); this.context = newVAlue; &#125;, &#125;,&#125; 在父组件中调用 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;quill :value.sync="value"&gt;&lt;/quill&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Quill from '@/components/quill.vue'export default &#123; data() &#123; return &#123; value:'你好世界' &#125; &#125;, components: &#123; Quill &#125;&#125;&lt;/script&gt; 如果你不仔细发现 你会觉得你成功了===&gt; 数据无法回显页面一打开我们一开始给的默认值没有显示在富文本里面，这要是回显评论全是空呀。如何解决： 12345//在子组件中// 页面挂在到DOM树后 对富文本内的v-model赋一次值 mounted () &#123; this.context = this.value; &#125;, 最后的成果图 节省大家复制粘贴时间，最后整个组件长这个样子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!-- 页面 --&gt;&lt;template&gt; &lt;div&gt; &lt;quill-editor v-model="context" ref="myQuillEditor" :options="editorOption" @input="$emit('update:value', $event)" &gt; &lt;/quill-editor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;quillEditor, Quill&#125; from 'vue-quill-editor';import &#123;container, ImageExtend, QuillWatch,&#125; from 'quill-image-extend-module';import &#123;quillRedefine&#125; from 'vue-quill-editor-upload';import ImageResize from 'quill-image-resize-module';Quill.register('modules/ImageResize', ImageResize )Quill.register('modules/ImageExtend', ImageExtend);export default &#123; mounted () &#123; this.context = this.value; &#125;, props:&#123; value:&#123; type:String, &#125;, &#125;, data() &#123; return &#123; context:'', // 富文本框参数设置 editorOption: &#123; modules: &#123; ImageExtend: &#123; // 如果不作设置，即&#123;&#125; 则依然开启复制粘贴功能且以base64插入 name: 'fileFile', // 图片参数名 size: 5, // 可选参数 图片大小，单位为M，1M = 1024kb action:'', // 服务器地址, 如果action为空，则采用base64插入图片 // response 为一个函数用来获取服务器返回的具体图片地址 // 例如服务器返回&#123;code: 200; data:&#123; url: 'baidu.com'&#125;&#125; 则 return res.data.url response: (res) =&gt; &#123;// 图片上传成功或错误 回调方法 成功后将图片地址return出去 return res.filePath; &#125;, headers: (xhr) =&gt; &#123; // 可选参数 设置请求头部 // xhr.setRequestHeader('Content-Type','multipart/form-data') &#125;, sizeError: () =&gt; &#123;&#125;, // 图片超过大小的回调 start: () =&gt; &#123;&#125;, // 可选参数 自定义开始上传触发事件 end: () =&gt; &#123;&#125;, // 可选参数 自定义上传结束触发的事件，无论成功或者失败 error: () =&gt; &#123;&#125;, // 可选参数 上传失败触发的事件 success: () =&gt; &#123; &#125;, // 可选参数 上传成功触发的事件 change: (xhr, formData) =&gt; &#123; // xhr.setRequestHeader('myHeader','myValue') // formData.append('token', 'myToken') &#125; // 可选参数 每次选择图片触发，也可用来设置头部，但比headers多了一个参数，可设置formData &#125;, toolbar: &#123; // 如果不上传图片到服务器，此处不必配置 container: container, // container为工具栏，此次引入了全部工具栏，也可自行配置 handlers: &#123; 'image': function (value) &#123; // 劫持原来的图片点击按钮事件 自定义图片上传 // if (value) &#123; // // 触发input框选择图片文件 // document.querySelector('.avatar-uploader input').click() // &#125; else &#123; // this.quill.format('image', false); // &#125; QuillWatch.emit(this.quill.id) &#125; &#125; &#125;, ImageResize: &#123; //调整上传过后图片大小配置。 displayStyles: &#123; backgroundColor: 'black', border: 'none', color: 'white' &#125;, modules: [ 'Resize', 'DisplaySize','Toolbar' ] &#125;, &#125;, &#125; &#125; &#125;, methods: &#123; &#125;, watch: &#123; // 页面 value(newVAlue)&#123; this.context = newVAlue; &#125;, &#125;, filters: &#123;&#125;, computed: &#123;&#125;, components: &#123; quillEditor, quillRedefine, Quill &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>富文本</tag>
        <tag>Quill</tag>
      </tags>
  </entry>
</search>
